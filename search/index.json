[{"content":"石家庄\u0026mdash;-5天4夜行 这也算是我第一次好好体验北方环境和遇见北方人民生活。主线任务是来参加2025年中国机器人大赛，支线是来感受一下北方人民的生活，美食，景色。总结感受是人都很热心善良，美食也是真的好吃！就是10月份的天太冷了，而且吹的风很干，能很明显感受出来跟南方这边的冬天的冷不是这样的干冷。突然想到觉得可能是南方是“凉”，北方才是“冷”！(胡话较多，安心享用🙂‍↕️)\n10月15日 启程 依旧15个小时的硬座火车。15号下午5点赶到火车站大家一起上车，不知道是不是坐太多次了，西安的18个小时，烟台的24个小时。已经没有那么恐惧？或者沮丧？说不上来。这次总共去了10个人，在车上打了会儿小游戏，打会儿扑克牌，时间也慢慢过去了。也没有很痛苦对吧？不过在车上坐着睡着真的好不舒服，坐的屁股痛。依稀记着好像就那么靠座位上眯会儿，在桌角单手趴会儿，迷糊，迷糊到了16号早上5点多。脑细胞重新开始运转，抬眼间突然发现一抹暗亮红在车窗的里面，瞬间确认精神清醒。看到外面的视野也变宽，几处房屋屋顶变平，我知道我们应该不在南方了。是晨起的太阳。透过有几处斑点的窗户我看到那一线红，我一时很难形容上来，于是二话没说把手机拿出来将它记录在了我的照片里。(我知道，人的记忆是有限的，发生过的事，遇到太多的景，遇到太多的人，如果我10年20年想起我又该从何想起呢？又或是我给看到这里的人我又该怎么共享心情呢？我现在找到的答案是用照片中的像素来记录下每一个我的心情瞬间！)但是期间有好多数遮挡了，可是我还是迅速抓住了它的“展示”时间☺️。\n10月16日 抵达 16号上午的9点左右抵达石家庄站，没来的及爬出地面，来到地铁站口马不停蹄赶往石家庄会展中心，(比赛赛场需要先当天报道及熟悉场馆)。到会展中心站出地铁站的瞬间第一眼占满我的眼睛视野内容就是一偏大雾。真的就是很明显感受出来的冷，感觉当天应该是晴天，正常是能看到太阳的，但是满眼向远处看就只剩下“雾”。切身体会了那边的空气环境确实很符合重工业城市的“刻板印象”。当天就事正常地签到熟悉，这次赛场的场馆很大，但是也挺方便，不像上次专项赛在学校每个赛场要去不同的楼还要爬楼梯，太麻烦。也参观看到很多其他的赛项，挺好，我看到的也就只剩挺好的。同样也看到了车型的搬运赛道场地，有感慨但也很快没了这股感慨。当天我也是平常给大家打打杂，搬搬东西，看好各组的进度状况。意外情况发生在当天的晚上去酒店入住，办理入住时和我们说没有房间了，要让我们跟其他房间协调，原本我们定的3间房，结果最终酒店那边人员口上说的“给我们升房间”，我们7个男生住她所谓的“豪华套房”，其实房间非常小，里面只有三张床，一个卫生间，总共不超过两个房间的大小。我们跟她沟通了很久，当时也已经接近晚上10点，大家累了一天没休息好，无奈实在不想折腾换酒店了。期间还有非常多毛语(应用赣州话读此“毛”哦，考虑到未成年孩子万一不小心看到此处的吐槽会不会不好呢？🤫)的地方，此处真的省略几千字的情绪发言!也告诫大家在外面碰见这样唬人差劲的酒店自己态度强硬一点，赶紧！跑！(后续几天我们住的都非常难受，懒得费笔字再吐槽了！)\n10月17日 调试 拖起沉重的躯体，还未来得及消散前一天的疲惫就匆忙7点多又赶往会场陪同大家一起调试，这天还下了点小雨，更冷了，“一场秋雨一场寒”，不记得是那时候车上司机谁说了一嘴🤧。对于那天的调试记得的已经非常少了，为数不多的印象就是给大家调试协助拿东西，提解决思路，帮大家点外卖拿外卖，纯打杂🥱。但还是好累，即使这次不是我主要参赛，但还是在感觉奔走于四处，腿走了很多。\n10月18日 比赛 这次比赛主要是分两天，18号和19号。18号当天是舞蹈，医疗和服务组需要比赛，我主要在医疗组这边帮忙给他们搬东西提供部分问题解决方案，帮他们梳理分析问题，往往参赛的时候我也不能直接参与，他们本人参赛的时候在紧张混乱的情况下反而最需要人来帮忙梳理问题。服务组那边前一天晚上调试到好晚，第二天去的也很早，但是还是没有发挥好，然后有人心理落差感很大。当时其实我非常能理解他们的心情，我就跟他分享当时烟台我结束的境况：专项赛当时我比赛结束的那一刻我就已经知道结果了，我从比赛场地上把我的车抱起来，最后一点理智推动着我拿着车去给裁判检查pcb丝印，我都不知我是怎么收拾的物料，一句话没说，当时什么情绪也没有，沿着人群的旁边，我眼神也不知道看向哪里，就是很空白的把车慢慢的装好封箱，整理好工具箱，收拾好电脑包，靠在箱子旁边什么也没说。至今我也不知道当时是什么心情，包括现在，写下这些的时候我也是空白的，没有任何情绪，或许是我根本就不知道我应该是要有什么情绪呢？愤怒？悲伤？可惜？松气？解放？颓废？开心？都不是吧.可能是这两年这么多的日夜，这么多调试，装机，拆机，搭建环境。从选型模块，主控选择，视觉方案，摄像头圆环识别的实现，颜色识别的实现，陀螺仪选型，机械臂舵机调试，底盘电机的调试，整体结构设计，物料装载结构设计，跟坤子爪子结构设计，包括前面集物料结构的设计改版，主控freertos系统架构搭建，通讯协调，任务线程协调，比赛任务逻辑的完善调试等等。它的任何一个细节，或许是这两年来总的结合，或许当时的我空白里闪过的是如此，或许我在想的是我的命运里本就与结果无缘，或许很多事情我都与结果无缘，比赛的结果更是特别而已罢了。害，一不小心就跟他说了这么多，我不知道我说的如此之多他有没有听进去，或许我是来安慰他的，又或许我是来安慰当初烟台的我，这我不得而知，也不愿意去知道了。因为我知道这些都是我的一部分，他们已经是我的一部分了。聊了一会儿我就提议去买这里的纪念品，就是朋友圈当时发的那些好多生肖盲盒！当时说的是10个里面开9个盲盒，我们一共买了3盒，结果所有的3个，里面的所有的都是一样的，唯独开不出来那个兔子🫤。那天晚上后面大家提议好好吃一顿，随后挑了一家铁锅炖。第一次尝体验了一下北方的习俗美食，玉米饼贴着，中间是一种忘了叫什么河清鱼还是啥来着，味道确实独特。还尝了一个河北的同学推荐的他小时候好爱喝的特色饮料:杏仁露，味道确实好“怪”，大家确实都有点尝不惯，说不上来的味道，有机会遇到了也可以去试试。\n10月19日 比赛 第二天的赛程主要还是人形竞速和医疗组的比赛。人形正常发挥本来还在担心怕有出问题，但还是安然无恙地拿下了他们组的冠军！当时听到这个消息的是算放下心，也算我们这一代，这一行人较为圆满的比赛完结了吧。看着他们抱着奖杯，拿在手上的时候还是很有感触.然后原本我们定的是3晚那个酒店，19号中午的酒店，我们一刻也等不及就赶紧收拾完东西换新的民宿了。名宿的阿姨人很好，房间也好大。房间的户型包括房间的结构，是客厅上有一个露天的楼梯，二楼楼梯转角有一个榻榻米，二楼正中间的房间是落地窗，可以看到楼下沙发，很宽敞，感觉装修的风格也很喜欢。反正整体的感觉就很好，唯独可惜的就是没有留下照片。中午正要解决午饭，听名宿阿姨说石家庄有一个很出名的吃的是安徽板面？安徽的版面在石家庄出了名，那我可要去尝尝看。就在楼下有一个，点了一份加腊肠。真的很好吃，反正那个腊肠是给我香迷糊了，配着他那个宽面非常不错，感觉是好的在哪都会吸引人，嗯没错。然后当天下午我们办理完入住，所有比赛都结束了，准备好好放松。晚上就去了封面夜市-正定商品夜市。确实好多小吃，都是人，看见有吃蝎子昆虫的，我是实在不敢尝。尝了那边的大油边，冻梨，逛了一会儿就差不多回去休息了，大家那几天也忙着调试比赛，还是好好休息养足精神准备第二天好好玩。(批斗一下，晚上回去叫他们做攻略，结果他们的口供都很统一：“我们一键跟随”).\n10月20日 吃玩 早上7点多就赶早大家起来了，准备去尝一尝这边的特色早餐，非得来试试了就是。到了正定古城里面，下车，冷，透过我衣服的冷。跟着地图找了一会儿，到了。看着门面还是一股复古老风，大家一拥进了店，“您好，我们要一份羊肉烧麦和一份牛肉牛肉烧麦，加一份羊杂汤”。是的，就是来赶早吃王家烧麦来的😋。还去对面的早餐店里买了一份胡辣汤，入口是一股胡椒粉的味道，对，然后一点麻麻的。烧麦好吃，皮薄，咬着还有汤流出来，沾点醋，好吃😋。吃完大家肚子也暖会儿过来，就在古城里面走走逛逛，记不得是先去了哪两个的寺，然后走到了赵云故里，给他们做摄影师来了，拍了好多照片(不知是不是我的隐藏属性，慢慢学会给大家找角度，会一点点构图，之前本来就有想好好学拍照呢，包括这次三江校区的那几个小兄弟，真的觉得他们人挺好的。之前就是在专项的路上碰上了，在同一个火车，通一节车厢呢，返程也是！！哈哈哈，所以说缘分有时候还真是！我们感觉也好聊的来，都有很多类似的经历呢！所以我们常说的就是，“我懂你”。真的有一种“相遇恨晚”的感觉，不戳的相遇呢！给他们拍照的时候就又感觉是不是拍摄属性大发，稍微放一张，纯新手勿喷呢！！hhh)。故里里面我就没去了，然后就是逛去了荣国府。是的，红楼梦里所说的那个荣国府，其实是当时老版红楼梦电视剧的拍摄地，走走停停。因为要赶下午5点的火车，所以也没有再继续好好探究一下这座古都了，就回去收拾东西启程准备离开了。在去火车站的路上，遇到一位货拉拉的司机，人很好呢，让hj给坐它车厢后面(后面他出来说里面就像被关在小黑屋，又冷又晃，一副被人霸凌的可怜感hhh)，路上给我介绍石家庄天气啊，这个地方咋样，历史以前是啥啊，好多好多(这次去最大的一个体验就是北方人民的这种大方，自在，热情的性格是真的好好，真的要好好给他们点大赞👍️)但是最后快到火车站，我们想去的是东门，跟司机说，他自信地说“我10分钟就能到那里”，给我一种莫名的心安，但是后面司机导到的西站口，硬是在那里走了半个小时，我现在还记得我们在同一个路口绕过了两遍，我一直憋着不好意思笑出声来，又想着后面的同伴还在那个黑漆漆的箱子里不知道啥情况，一直在那边转弯绕着，他就在后面左晃又晃🤣🤣。下面放一张当时的聊天真的给我爆笑了。最后实在不行我就让他给我们放在距离最近的路边了，司机下车给我们卸下东西招呼我都没来的及打他就上车走了，有一种灰溜溜的搞笑感🤣。后面在车站附近，我说一定要来尝一尝驴肉火烧！后面找了附近一家点了一份疙瘩汤和驴肉焖子火烧，真的好吃，不油配旮沓汤不戳！吃饱了看到旁边有家饸烙面馆，本来就吃撑了，硬是三个人点了一份饸烙面，味道也好，素油香。还有给我们带回来的黄庄月饼，特地打算带回来尝尝，不是很清楚这个特产的特点，但是味道确实好吃，我买的紫薯和板栗都好吃，还邮了部分回家😁。\n完结分享 扬扬又洒洒，胡话连篇的一次，很新的体验，第一次以这样的方式以这样的内容将旅行感受记录(或许这就是当初我决定将这个博客网站搭建出来的初心含义)，不知道记得合不合适，写的内容方式好不好，我不知道。(写完我发现还是挺有意思的，用不到5k字内容，将5天来的旅程基本上都登记在册🤔文字，挺有意思)但是我想现在，用照片和文字将时间和感受定格下，或许以后给我，给我身边的朋友分享下这些点点瞬间。因为我知道，我记忆中的这些瞬间都会随着时间而逐渐消失，没有永恒的回忆，我知道还有未来更远的事情在等着我。现在我将他们记录暂留了下来，这或许就是我将它们写下的意义，写下的心情感受，事件事物，我的第一次旅行碎片.好了，石家庄-我们有缘再会.🌁\n","date":"2025-10-24T00:00:00Z","image":"https://prominsegsj.github.io/p/shijiazhuang/2_hu_37fb093f975cc18f.jpg","permalink":"https://prominsegsj.github.io/p/shijiazhuang/","title":"石家庄之行"},{"content":"ROS2 学习笔记 本次ROS2学习笔记开发环境同步上一篇linux学习笔记的虚拟机ubantu24.04.2系统版本以及ROS2的jazzy版本下的记录。\n大部分是本人的学习笔记，学习视频主要是鱼香ROS机器人他的知识点和视频内容很详细，真的是在印证\u0026quot;授人以鱼不如授人以渔\u0026quot;。此外还会加上一些个人理解，希望能帮助加深理解，仅供学习参考！\n3. ROS2学习笔记 大部分是本人的学习笔记，学习视频主要是鱼香ROS机器人他的知识点和视频内容很详细，真的是在印证\u0026quot;授人以鱼不如授人以渔\u0026quot;。此外还会加上一些个人理解，希望能帮助加深理解，仅供学习参考！\n3.1 ros2 run (1). 命令ros2 run会从一个软件包中启动一个可执行文件： ros2 run \u0026lt;package_name\u0026gt; \u0026lt;executable_name\u0026gt; (2). 解释： eg：要运行turtlesim，请打开一个新的终端，并输入以下命令： ros2 run turtlesim turtlesim_node turtlesim窗口将会打开 这里，包名是 使用 turtlesim ，可执行文件名是 turtlesim_node 然而，我们还不知道节点名称。您可以使用 ros2 node list 命令查找节点名称。 3.2. ros2 node list (1). ros2 node list 命令将显示所有正在运行的节点的名称。当您想与节点进行交互或者系统运行多个节点时需要跟踪它们时，这特别有用。 (2). 解释： (A). 在另一个终端中打开新的终端，同时 turtlesim 仍在运行，请输入以下命令： ros2 node list (B). 终端将返回节点名称： /turtlesim (C). 再打开一个新的终端，并使用以下命令启动 teleop 节点： ros2 run turtlesim turtle_teleop_key 【在这里，我们再次引用了“turtlesim”软件包，但这次我们的目标是名为“turtle_teleop_key”的可执行文件】\n(D). 返回到之前运行ros2 node list的终端，再次运行该命令。你将会看到两个活动节点的名称：\n/turtlesim /teleop_turtle 3.3. 重映射 (1). 重映射：允许你重新分配默认节点属性，如节点名称、话题名称、服务名称等，以自定义的值。在上一个教程中，你在turtle_teleop_key上使用了重映射来改变cmd_vel话题和目标节点为turtle2。 (2). 解释： - (A). 现在，让我们重新分配 /turtlesim 节点的名称。在一个新的终端中运行以下命令： - ros2 run turtlesim turtlesim_node \u0026ndash;ros-args \u0026ndash;remap __node:=my_turtle - (B). 由于您再次调用ros2 run 启动了turtlesim，将会打开另一个turtlesim窗口。但是，现在如果您返回到之前运行ros2 node list的终端，并再次运行该命令，您将看到三个节点名称： - /my_turtle - /turtlesim - /teleop_turtle 3.4. ros2节点信息 (既然您知道了节点的名称，您可以使用以下命令访问有关它们的更多信息)\nros2 node info \u0026lt;node_name\u0026gt; (例). 要查看您最新的节点my_turtle，请运行以下命令： ros2 node info /my_turtle ros2 node info返回订阅者、发布者、服务和动作的列表，即与该节点进行交互的ROS图连接。输出应该如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /my_turtle Subscribers: /parameter_events: rcl_interfaces/msg/ParameterEvent /turtle1/cmd_vel: geometry_msgs/msg/Twist Publishers: /parameter_events: rcl_interfaces/msg/ParameterEvent /rosout: rcl_interfaces/msg/Log /turtle1/color_sensor: turtlesim/msg/Color /turtle1/pose: turtlesim/msg/Pose Service Servers: /clear: std_srvs/srv/Empty /kill: turtlesim/srv/Kill /my_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters /my_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes /my_turtle/get_parameters: rcl_interfaces/srv/GetParameters /my_turtle/list_parameters: rcl_interfaces/srv/ListParameters /my_turtle/set_parameters: rcl_interfaces/srv/SetParameters /my_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically /reset: std_srvs/srv/Empty /spawn: turtlesim/srv/Spawn /turtle1/set_pen: turtlesim/srv/SetPen /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute /turtle1/teleport_relative: turtlesim/srv/TeleportRelative Service Clients: (none) Action Servers: /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute Action Clients: (none) 3.5. 编译运行C++文件 (1). 先在目录下编写CMakeFiles.txt：\n示例： 1 2 3 4 5 6 7 8 9 10 cmake_minimum_required(VERSION 3.8) project(ros2_cpp) add_executable(ros2_cpp_node ros2_cpp_node.cpp) find_package(rclcpp REQUIRED) # 直接查找到对应的头文件和库文件 message(STATUS ${rclcpp_INCLUDE_DIRS}) #头文件及rclcpp依赖的头文件 message(STATUS ${rclcpp_LIBRARIES}) #库文件及rclcpp依赖的库文件 target_include_directories(ros2_cpp_node PUBLIC ${rclcpp_INCLUDE_DIRS}) #头文件包好到ros2_cpp_node文件内 target_link_libraries(ros2_cpp_node ${rclcpp_LIBRARIES}) #库文件链接到ros2_cpp_node文件内 (2). 再在当前目录下运行终端命令：\ncmake . make 【之后会生成一个可以执行文件为绿色的，直接终端输入既可运行】 3.6. 创建功能包 先创建一个工作空间，然后再工作空间下新建src文件夹，进入src文件夹内运行：ros2 pkg create demo_python_topic \u0026ndash;build-type ament_python \u0026ndash;dependencies rclpy example_interfaces \u0026ndash;license Apache-2.0【中间的\u0026ndash;是可选项配置，有编译版本，添加的依赖，许可证，存放目录等等】 然后再回到工作空间文件夹内运行：colcon build (✔️). 启用节点函数 setup.py添加： \u0026lsquo;python_NODE = demo_python_pkg.pyhon_node:main\u0026rsquo;, 【生成可执行文件的名称以及包名和路径，函数名称】 (✔️). 将需要导入的库加入到package.xml功能包清单文件的声明里面导入包，添加依赖信息： 1 \u0026lt;depend\u0026gt;rclpy\u0026lt;/depend\u0026gt; (✔️). 添加完之后需要开启构建功能包：colcon build 【终端直接执行命令，执行完之后是会根据你之前配置的调用函数拷贝复制一份一模一样的.py文件，然后运行调用的是复制过来的文件，不是原来的本身的文件，所以后续写了更新之后它的包调用的是你上一次拷贝的，不是你新写的】 (✔️). 修改环境变量：source install/setup.bash【此文件是创建时生成的】\n或者也可以手动添加这个环境变量： 1 export PYTHONPATH=/home/robot/chapt2/install/demo_python_pkg/lib/python3.12/site-packages:$PYTHONPATH # $PYTHONPATH表示原来的路径不变，缩写，然后加：前面加需要添加的路径 3.7. 其他 (A). echo 🔵查看当前ROS1/ROS2：echo $ROS_VERSION【中间有个下划线】 🔵查看当前ROS版本：echo $ROS_DISTRO (B). 总的打印环境变量信息 🟡printenv 打印特定的信息，进行信息过滤：printenv | grep 想要打印的环境变量 (C). 修改环境变量的文件位置 🟣export 环境变量名称=想要修改的文件位置（仅在当前终端临时修改成效，再另开还是原来的环境位置） (D). 在linux中，以.开头的文件或者文件夹，是隐藏文件 🔴(例). 启动自运行脚本：~/.bashrc (E). 安装python插件在vscode中的代码注释ctrl加左键，或者长放提示的注释形式 (F). 增加可执行文件的执行权限，白色为较低权限，绿色为较高权限可进行执行： 🟠chmod a+x 文件名 (G). 查看节点的具体信息 ⚫ros2 node info /节点名称 打印目标话题的信息 ros2 topic echo 目标话题的名称 查看话题的详细信息 ros2 topic info 目标话题的名称 打印话题的某个接口的详细信息 ros2 interface show 接口名称 发布一个话题 ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist \u0026ldquo;{linear: {x: 0.4, y: 0.0} , angular: {z: 0.0}}\u0026rdquo; 【话题名称＋接口名称＋发布信息】\n打印当前话题列表 ros2 topic list 3.8 工作空间(WorkPlace) 创建使用工作空间 mkdir -p chapt2_ws/src 【-p表示创建目录下的文件夹】 mv demo_cpp_pkg/ chapt2_ws/src/【将要整合的包剪切移动到工作空间下】 mv demo_cpp_pkg/ chapt2_ws/src/ cd chapt2_ws/【进入工作空间再构建主，保证架构的清晰完整】 colcon build 【构建】 如果有功能包的依赖关系需要更改构建顺序就在对应需要依赖的package.xml文件内添加对应的依赖包既可，系统就会先编译构建被依赖的包 被依赖的包名 3.9 Python学习 简单的类和函数以及init方法的理解 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class PersonNode: def __init__(self,name_value:str,age_value:int): print(\u0026#39;PersonNode __init__方法被调用并且还添加了两个属性！\u0026#39;) self.name=name_value self.age=age_value def eat(self,food_name:str): \u0026#34;\u0026#34;\u0026#34; 方法：吃东西 :food_name 食物名字 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) def main(): node = PersonNode(\u0026#39;法外狂徒张三\u0026#39;,20) node2 = PersonNode(\u0026#39;法外狂徒里斯\u0026#39;,19) node.eat(\u0026#39;黄焖鸡米饭\u0026#39;) node2.eat(\u0026#39;鱼香肉丝\u0026#39;) 简单的继承思想 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import rclpy from rclpy.node import Node #倒入Node类 class PersonNode(Node):#此处的Node就是继承于导入的rclpy.node里面的Node类 def __init__(self,node_name:str,name_value:str,age_value:int): print(\u0026#39;PersonNode __init__方法被调用并且还添加了两个属性！\u0026#39;) super().__init__(node_name) #初始化节点 self.name=name_value self.age=age_value def eat(self,food_name:str): \u0026#34;\u0026#34;\u0026#34; 方法：吃东西 :food_name 食物名字 \u0026#34;\u0026#34;\u0026#34; # print(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) self.get_logger().info(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) #将内容添加到ros日志里面并且打印 def main(): rclpy.init() #使用ros2前需要执行init初始化资源配置 node = PersonNode(\u0026#39;zhangsan_node\u0026#39;,\u0026#39;法外狂徒张三\u0026#39;,20) node.eat(\u0026#39;黄焖鸡米饭\u0026#39;) rclpy.spin(node) #收集节点数据 rclpy.shutdown() #关闭节点 多线程及回调函数 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import threading import requests class Download: def download(sel,url,callback_word_count): print(f\u0026#34;线程：{threading.get_ident()}开始下载：{url}\u0026#34;) response = requests.get(url) response.encoding=\u0026#39;utf-8\u0026#39; #给请求的结果一个编码 callback_word_count(url,response.text) #调用回调函数 #pass def start_download(self,url,callback_word_count): thread = threading.Thread(target=self.download,args=(url,callback_word_count)) #创建一个新的线程 target目标函数，args需要传入的参数 thread.start() #启动线程 # pass def world_count(url,result): \u0026#34;\u0026#34;\u0026#34; 普通的函数，用于回调 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{url}:{len(result)}-\u0026gt;{result[:5]}\u0026#34;) def main(): download = Download() download.start_download(\u0026#39;url网址\u0026#39;,world_count) download.start_download(\u0026#39;url网址\u0026#39;,world_count) download.start_download(\u0026#39;url网址\u0026#39;,world_count) 3.10 C++学习 C++ vscode的扩展遇到include报错找不到路径就在他扩展配置中添加类似：/opt/ros/jazzy/include/** 依据类似的面向对象编程原理，代码示例如下： 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; // 定义一个PersionNode的类并且继承rclcpp的Node作为父类 class PersonNode : public rclcpp::Node { private: // 声明 std::string name_; int age_; public: PersonNode(const std::string \u0026amp;node_name, const std::string \u0026amp;name, const int \u0026amp;age) : Node(node_name) /*调用父类的构造函数，等同于python中的 super().__init__(),传入节点的名称作为参数*/ { this-\u0026gt;name_ = name; this-\u0026gt;age_ = age; }; void eat(const std::string \u0026amp;food_name) { RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;我是%s,%d岁了,爱吃%s\u0026#34;, this-\u0026gt;name_.c_str(), this-\u0026gt;age_, food_name.c_str()); }; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;PersonNode\u0026gt;(\u0026#34;persion_node\u0026#34;, \u0026#34;小过\u0026#34;, 20); node-\u0026gt;eat(\u0026#34;黄焖鸡米饭\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); return 0; } 将代码添加到src/目录下创建的person_node.cpp文件内，编写好后再到CmkeList.txt文件内添加指定输出的可执行文件名和需要连接的包名以及执行编译 最终进入到CmkeList.txt目录结构下（例如图片中的目录应进入chart2_ws/）运行 colcon build #编译 source install/setup.bash C++新特性 auto自动类型推导，示例代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;iostream\u0026#34; int main() { //auto 的自动类型推导 auto xn = 2 ; //int xn = 2; auto yn = 3.14f; //float yn = 3.1415; auto zn = \u0026#39;a\u0026#39;;//char zn = \u0026#39;a\u0026#39;; std::cout\u0026lt;\u0026lt;xn\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;yn\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;zn\u0026lt;\u0026lt;std::endl; return 0; } 共享指针 使用共享指针不要用重复新增内存地址，并且可以自动回收不会造成内存泄漏，例如下面的make_shared例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;iostream\u0026#34; #include \u0026#34;memory\u0026#34; int main() { auto p1 = std::make_shared\u0026lt;std::string\u0026gt;(\u0026#34;This is a str.\u0026#34;); // std::make_shared\u0026lt;数据类型/类\u0026gt;（参数）；返回值，对应的共享指针 std::shared_ptr\u0026lt;std::string\u0026gt; 写成 auto std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 1 auto p2 =p1; std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 2 std::cout\u0026lt;\u0026lt;\u0026#34;p2的引用计数\u0026#34;\u0026lt;\u0026lt; p2.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2.get()\u0026lt;\u0026lt;std::endl; // 2 p1.reset(); //释放引用，不指向“This is a str.”所在内存 std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 0 std::cout\u0026lt;\u0026lt;\u0026#34;p2的引用计数\u0026#34;\u0026lt;\u0026lt; p2.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2.get()\u0026lt;\u0026lt;std::endl; // 2-1=1 std::cout\u0026lt;\u0026lt;\u0026#34;p2的指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2-\u0026gt;c_str()\u0026lt;\u0026lt;std::endl; // 调用成员方法 This is a str. return 0; } 匿名函数 换一种语法的函数 下面lambda函数示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;iostream\u0026#34; #include \u0026lt;algorithm\u0026gt; int main() { auto add = [](int a,int b) -\u0026gt; int {return a+b;}; int sum = add(200,50); auto print_sum = [sum]() -\u0026gt; void //此处直接将sum内容调用过来 { std::cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;std::endl; }; print_sum(); return 0; } 函数包装器，理解下面示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; // 自由函数 void save_with_free_fun(const std::string \u0026amp;file_name) { std::cout \u0026lt;\u0026lt; \u0026#34;自由函数：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; } // 成员函数 class FileSave { private: public: FileSave(/* args */) = default; ~FileSave() = default; void save_with_member_fun(const std::string \u0026amp;file_name) { std::cout \u0026lt;\u0026lt; \u0026#34;成员方法：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; }; }; int main() { FileSave file_save; // Lambda函数 auto save_with_lambda_fun = [](const std::string \u0026amp;file_name) -\u0026gt; void { std::cout \u0026lt;\u0026lt; \u0026#34;Lambda 函数：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; }; //常见的普通函数调用 // save_with_lambda_fun(\u0026#34;file.txt\u0026#34;); // Lambda函数的调用 // file_save.save_with_member_fun(\u0026#34;file.txt\u0026#34;); // 成员函数的调用 // save_with_free_fun(\u0026#34;file.txt\u0026#34;); // 自由函数的调用 //使用函数包装器之后的： std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save1=save_with_free_fun; std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save2=save_with_lambda_fun; //成员函数，放入包装器 std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save3=std::bind(\u0026amp;FileSave::save_with_member_fun, \u0026amp;file_save,std::placeholders::_1); //保护类的其他方法不被调用 //统一的调用方法 save1(\u0026#34;file.txt\u0026#34;); save2(\u0026#34;file.txt\u0026#34;); save3(\u0026#34;file.txt\u0026#34;); return 0; } 3.11 多线程以及回调函数 C++具体(有关http服务的请求等部分较为复杂，详细请看ROS2 小鱼) 【打开http服务：python3 -m http.server】 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; //多线程 #include \u0026lt;chrono\u0026gt; //时间相关 #include \u0026lt;functional\u0026gt; //函数包装器 #include \u0026#34;cpp-httplib/httplib.h\u0026#34; //下载相关 class Download { private: /* data */ public: void download(const std::string \u0026amp;host,const std::string \u0026amp;path,const std::function\u0026lt;void(const std::string\u0026amp;,const std::string\u0026amp;)\u0026gt; \u0026amp;callback_word_count) { std::cout\u0026lt;\u0026lt;\u0026#34;线程\u0026#34;\u0026lt;\u0026lt;std::this_thread::get_id()\u0026lt;\u0026lt;std::endl; httplib::Client client(host); auto response=client.Get(path); if(response\u0026amp;\u0026amp;response-\u0026gt;status==200) { callback_word_count(path,response-\u0026gt;body); } }; void start_download(const std::string \u0026amp;host,const std::string \u0026amp;path,const std::function\u0026lt;void(const std::string\u0026amp;,const std::string\u0026amp;)\u0026gt; \u0026amp;callback_word_count) { auto download_fun=std::bind(\u0026amp;Download::download,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3); std::thread thread(download_fun,host,path,callback_word_count); thread.detach(); //线程分离！ }; }; int main() { auto d=Download(); auto word_count =[](const std::string \u0026amp;path,const std::string \u0026amp;result) -\u0026gt;void { std::cout\u0026lt;\u0026lt;\u0026#34;下载完成\u0026#34;\u0026lt;\u0026lt;path\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;result.length()\u0026lt;\u0026lt;\u0026#34;-\u0026gt;\u0026#34;\u0026lt;\u0026lt;result.substr(0,5)\u0026lt;\u0026lt;std::endl; }; d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path1地址\u0026#34;,word_count); d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path2地址\u0026#34;,word_count); d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path3地址\u0026#34;,word_count); std::this_thread::sleep_for(std::chrono::milliseconds(1000*100));//休眠10s return 0; } 3.12 话题 话题的发布 示例python节点代码发布话题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import rclpy from rclpy.node import Node import requests from example_interfaces.msg import String from queue import Queue class NovelPuNode(Node): def __init__(self,node_name): super().__init__(node_name) self.get_logger().info(f\u0026#34;{node_name},启动！\u0026#34;) self.novel_queue_=Queue() #创建队列 放在前面 self.novel_publisher_ = self.create_publisher(String,\u0026#39;novel\u0026#39;,10) self.create_timer(5,self.timer_callback) def timer_callback(self): if self.novel_queue_.qsize()\u0026gt;0: line = self.novel_queue_.get() msg=String() #组装 msg.data=line self.novel_publisher_.publish(msg) self.get_logger().info(f\u0026#34;发布了：{msg} 这条信息！\u0026#34;) def download(self,url): response = requests.get(url) #发送开始请求 response.encoding=\u0026#39;utf-8\u0026#39; #给请求的结果一个编码 text =response.text self.get_logger().info(f\u0026#34;下载{url},{len(text)}\u0026#34;) for line in text.splitlines(): #获取到每一行的数据存储到队列中 按行分割 self.novel_queue_.put(line) def main(): rclpy.init() node = NovelPuNode(\u0026#39;novel_pub\u0026#39;) node.download(\u0026#39;http://0.0.0.0:8000/novel1.txt\u0026#39;) rclpy.spin(node) rclpy.shutdown() 订阅话题 python示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import espeakng import rclpy from rclpy.node import Node from example_interfaces.msg import String from queue import Queue import threading import time class NovelSubNode(Node): def __init__(self,node_name): super().__init__(node_name) self.get_logger().info(f\u0026#34;{node_name},启动！\u0026#34;) self.novels_queue_ =Queue() self.novel_subscriber_=self.create_subscription(String,\u0026#39;novel\u0026#39;,self.novel_callback,10) self.speech_thread_ =threading.Thread(target=self.speake_thread) self.speech_thread_.start() def novel_callback(self,msg): self.novels_queue_.put(msg.data) def speake_thread(self): speaker =espeakng.Speaker() speaker.voice=\u0026#39;zh-yue\u0026#39; while rclpy.ok(): #检测当前ROS上下文是否OK if self.novels_queue_.qsize()\u0026gt;0: text =self.novels_queue_.get() self.get_logger().info(f\u0026#39;朗诵：{text}\u0026#39;) speaker.say(text) #说 speaker.wait() #等他说完 else: # 让当前进程休眠1s time.sleep(1) def main(): rclpy.init() node = NovelSubNode(\u0026#39;novel_sub\u0026#39;) rclpy.spin(node) rclpy.shutdown() 安装espeakng过程中遇到的问题：（建议是直接创建一个合适的虚拟环境venv然后下载你后续需要的库，不要用全局系统） 直接先进入到你想要放置虚拟环境的文件中，建议是直接放到~/目录下，然后运行： 1 2 # 使用全局Python创建虚拟环境，并继承系统包 # /bin/python3 -m venv --system-site-packages ~/mvenv 随后在你的vscode中替换为你新建的环境： 之后你缺少哪个库，就在这个虚拟环境下直接：(pip install 库名 ) 既可 最终的编译后使用ros2 run 时需要提前在本工作空间新建一个.sh脚本文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash # 激活虚拟环境 source ~/mvenv/bin/activate # 配置 ROS2 环境 需要根据自己的系统来配置 source /opt/ros/jazzy/setup.bash # 配置你的工作空间 source ~/chapt3/topic_ws/install/setup.bash # 把虚拟环境的 Python 路径加入到 ROS2 的 Python 路径中 后续其他工程或者工作空间的python中需要ros2调用自己创建的虚拟环境的第三方库时直接修该这段中的对应虚拟环境的名词/位置即可 export PYTHONPATH=$PYTHONPATH:/home/robot/mvenv/lib/python3.12/site-packages echo \u0026#34;ROS2 + Python 虚拟环境已配置完成！\u0026#34; 然后正常colcon build和source install/setup.bash既可运行ros2 run C++发布话题控制小海龟运动 示例代码(仅发布话题)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; using namespace std::chrono_literals; class TurtlrCircleNode:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; //创建计时器 rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 public: explicit TurtlrCircleNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtlrCircleNode::timer_callback,this)); } void timer_callback() { auto msg=geometry_msgs::msg::Twist(); msg.linear.x=1.0; msg.angular.z=0.5; publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtlrCircleNode\u0026gt;(\u0026#34;turtle_circle\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 示例代码(订阅加发布话题 控制小海龟到设定的目标点) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: // rclcpp::TimerBase::SharedPtr timer_; //创建计时器 rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 实战话题小项目：获取系统状态并且qt显示，通过ROS通讯实现局域网通讯 第一步：自定义通讯接口 (1). 新建工作空间topic_practice_ws,在新的工作空间中新建src文件夹创建消息接口的功能包 ros2 pkg create status_interfaces \u0026ndash;dependencies builtin_interfaces rosidl_default_generators \u0026ndash;license Apache-2.0 (2). 在生成的工作包中新建msg文件夹新建好自己的的消息接口文件,(命名规则要求为骆驼峰命名，即开头第一个字母为大写,后缀为.msg),SystemStatus.msg 1 2 3 4 5 6 7 8 builtin_interfaces/Time stamp #记录时间辍引入其他功能包的消息接口，注意去除msg文件路径 string host_name # 主机名字 float32 cpu_percent # CPU使用率 float32 memory_percent # 内存使用率 float32 memory_total # 内存总大小 float32 memory_available # 内存剩于量 float32 net_sent # 网络发送数据总量 1MB=1Mb float32 net_recv # 网络数据接受总量 1MB=1Mb (3). 在cmakelist文件中添加一段： -```cpp # cmake 函数，来自rosidl_default_generators 用于将msg等消息将接口定义文件转换成库或者头文件类 rosidl_generators_interfaces{ ${PROJECT_NAME} \u0026ldquo;msg/SystemStatus.msg\u0026rdquo; DEPENDENCIES builtin_interfaces } (4). 再在package.xml文件中添加一行声明应用了其他文件功能包： \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; (5). 回到src同级目录下进行colcon build构建,之后先source install/setup.bash更新一下环境变量，之后可以运行：ros2 interface show status_interfaces/msg/SystemStatus 查看一下接口信息是否正确 第二步：系统信息获取和发布 (1). 先在同一个工作空间下新建一个python功能包 (2). 再新建一个py文件 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import rclpy from status_interfaces.msg import SystemStatus from rclpy.node import Node import psutil #获取系统信息库 import platform class SysStatusPub(Node): def __init__(self,node_name): super().__init__(node_name) self.status_publisher_ =self.create_publisher( SystemStatus,\u0026#39;sys_status\u0026#39;,10 ) self.timer_ =self.create_timer(1.0,self.timer_callback) def timer_callback(self): # builtin_interfaces/Time stamp #记录时间辍引入其他功能包的消息接口，注意去除msg文件路径 # string host_name # 主机名字 # float32 cpu_percent # CPU使用率 # float32 memory_percent # 内存使用率 # float32 memory_total # 内存总大小 # float32 memory_available # 内存剩于量 # float32 net_sent # 网络发送数据总量 1MB=1Mb # float32 net_recv # 网络数据接受总量 1MB=1Mb cpu_percent = psutil.cpu_percent() #cpu当前使用率 memory_info=psutil.virtual_memory() # 内存相关信息 net_io_counters=psutil.net_io_counters() # 网络输入输出相关信息 msg=SystemStatus() msg.stamp=self.get_clock().now().to_msg() msg.host_name=platform.node() msg.cpu_percent=cpu_percent msg.memory_percent=memory_info.percent msg.memory_total=memory_info.total/1024/1024 msg.memory_available=memory_info.available/1024/1024 msg.net_sent=net_io_counters.bytes_sent/1024/1024 msg.net_recv=net_io_counters.bytes_recv/1024/1024 self.get_logger().info(f\u0026#39;发布：{str(msg)}\u0026#39;)#ros信息终端打印信息 self.status_publisher_.publish(msg) #发布信息 def main(): rclpy.init() node=SysStatusPub(\u0026#39;sys_status_pub\u0026#39;) #创建节点 rclpy.spin(node) #spin运行节点 rclpy.shutdown()#运行完之后关闭 (3). 在setup.py文件中加入：\u0026lsquo;sys_status_pub=status_publisher.sys_status_pub:main\u0026rsquo;, (4). 最后colcon build以及source之后运行：ros2 run status_publisher sys_status_pub，之后可以打开另外一个终端source之后运行：ros2 topic echo /sys_status ，打印当前运行的sys_status_pub节点的发布的sys_status话题，此话题发布了电脑状态的msg信息 第三步：在功能包中使用QT (1). 在工作环境的src文件夹内新建status_display功能包，默认是cpp文件类型，需要加载rclcpp和status_interface，然后新建一个hello_qt.cpp文件 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QLabel\u0026gt; #include \u0026lt;QString\u0026gt; int main(int argc,char *argv[]) { QApplication app(argc,argv); QLabel* lable=new QLabel(); QString message=QString::fromStdString(\u0026#34;Hello Qt!\u0026#34;); lable-\u0026gt;setText(message); lable-\u0026gt;show(); app.exec();//执行应用，阻塞代码 return 0; } (2). 再在cmakelist文件中添加下面4行,之后构建运行即可 find_package(Qt5 REQUIRED COMPONENTS Widgets) # 查找库 add_executable(hello_qt src/hello_qt.cpp) # 添加可执行文件 target_link_libraries(hello_qt Qt5::Widgets) # 链接库 install(TARGETS hello_qt DESTINATION lib/${PROJECT_NAME}) # 备份文件 (3). 基于本实战系统状态显示项目，如下新建一个sys_status_display.cpp： 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QLabel\u0026gt; #include \u0026lt;QString\u0026gt; #include \u0026lt;rclcpp/rclcpp.hpp\u0026gt; #include \u0026lt;status_interfaces/msg/system_status.hpp\u0026gt; using SystemStatus = status_interfaces::msg::SystemStatus; class SysStatusDisplay : public rclcpp::Node { private: /* data */ rclcpp::Subscription\u0026lt;SystemStatus\u0026gt;::SharedPtr subscriber_; QLabel *lable; public: SysStatusDisplay(/* args */) : Node(\u0026#34;sys_status_display\u0026#34;) { lable = new QLabel(); subscriber_ = this-\u0026gt;create_subscription\u0026lt;SystemStatus\u0026gt;(\u0026#34;sys_status\u0026#34;, 10, [\u0026amp;](const SystemStatus::SharedPtr msg) -\u0026gt; void { lable-\u0026gt;setText(get_qstr_from_msg(msg)); }); lable-\u0026gt;setText(get_qstr_from_msg(std::make_shared\u0026lt;SystemStatus\u0026gt;())); lable-\u0026gt;show(); }; // msg.stamp=self.get_clock().now().to_msg() // msg.host_name=platform.node() // msg.cpu_percent=cpu_percent // msg.memory_percent=memory_info.percent // msg.memory_total=memory_info.total/1024/1024 // msg.memory_available=memory_info.available/1024/1024 // msg.net_sent=net_io_counters.bytes_sent/1024/1024 // msg.net_recv=net_io_counters.bytes_recv/1024/1024 QString get_qstr_from_msg(const SystemStatus::SharedPtr msg) { std::stringstream show_str; show_str \u0026lt;\u0026lt;\u0026#34;========系统状态可视化显示工具==========\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 数 据 时 间：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;stamp.sec\u0026lt;\u0026lt;\u0026#34;\\ts\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 主 机 名 字：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;host_name\u0026lt;\u0026lt;\u0026#34;\\ts\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; CPU 使 用 率：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;cpu_percent\u0026lt;\u0026lt;\u0026#34;\\t%\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 使 用 率：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_percent\u0026lt;\u0026lt;\u0026#34;\\t%\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 总 量：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_total\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 剩 余：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_available\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 网 络 发 送：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;net_sent\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 网 络 接 受：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;net_recv\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;=====================================\u0026#34; ; return QString::fromStdString(show_str.str()); } }; int main(int argc, char *argv[]) { rclcpp::init(argc,argv); QApplication app(argc, argv); auto node=std::make_shared\u0026lt;SysStatusDisplay\u0026gt;(); std::thread spin_thread([\u0026amp;]()-\u0026gt;void{ rclcpp::spin(node); //启动node节点,阻塞代码 }); spin_thread.detach(); app.exec(); // 执行应用，阻塞代码 return 0; } (4). 更改好cmakelist文件内容，链接好库： 1 2 3 4 5 6 add_executable(sys_status_display src/sys_status_display.cpp) # 添加可执行文件 target_link_libraries(sys_status_display Qt5::Widgets) # 链接库 ament_target_dependencies(sys_status_display rclcpp status_interfaces) install(TARGETS hello_qt sys_status_display DESTINATION lib/${PROJECT_NAME} ) # 备份文件 (5). 最后分别运行status_publisher sys_status_pub和status_display sys_status_display 正常看到显示即大功告成！ 3.13 服务 初步认识使用服务：\n示例： 打开小海龟显示节点(记不起来就双tap) ros2 run turtlesim turtlesim_node 之后再打开另外一个终端(ctrl+alt+t)运行下面图片查看服务，查看某个服务消息详情，call启动一个服务消息 ros2 service list -t ros2 interface show turtlesim/srv/Spawn ros2 service call spawn turtlesim/srv/Spawn \u0026ldquo;{x: 1, y: 1}\u0026rdquo; 使用图形化交互界面：rqt 基于服务的参数通信\n服务的一些参数列表展示:ros2 param list 之后可以打印详细的参数介绍信息：ros2 param describe /turtlesim background_r 还可以打印获取当前参数的值：ros2 param get /turtlesim background_r 还可以设置当前参数的值：ros2 param set /turtlesim background_r 255 一般配置多个参数时最快便捷方法是导出yaml参数文件，之后编辑文件中的参数既可，随后运行相应节点时将yaml参数配置文件一起启用配置 导出服务参数为yaml文件： ros2 param dump /turtlesim \u0026gt; turtlesim_param.yaml 查看当前导出的yaml文件 cat turtlesim_param.yaml 启动节点时使用yaml的配置文件： ros2 run turtlesim turtlesim_node \u0026ndash;ros-args \u0026ndash;params-file turtlesim_param.yaml 【其实就是rclcpp.init(argc,argv)时将yaml传入作为初始化参数】 或者是rqt中的动态配置configuration直接调整修改值 自定义服务接口(人脸识别示例)\n新建号chapt4文件下src内新建一个chapt4_interfaces功能包：\nros2 pkg create chapt4_interfaces \u0026ndash;dependencies sensor_msgs rosidl_default_generators \u0026ndash;license Apache-2.0 再在功能包内新建srv服务接口文件夹，在此文件夹内新建FaceDetector.srv文件并且更改cmakelist和package.xml文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sensor_msgs/Image image #人脸图像 --- int16 number #识别到的人脸个数 float32 use_time #识别耗时 int32[] top #人脸在图像中的位置 int32[] right int32[] bottom int32[] left rosidl_generate_interfaces(${PROJECT_NAME} \u0026#34;srv/FaceDetector.srv\u0026#34; DEPENDENCIES sensor_msgs ) \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; 之后切换到src的同级目录下进行colcon build再source install/setup.bash ，最后运行ros2 interface show chapt4_interfaces/srv/FaceDetector 查看是否有对应的服务接口信息既可\n人脸检测python服务通信：(python在mvenv环境下)\n新建一个start_mvenv.sh文件一键配置虚拟环境 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash # 激活虚拟环境 source ~/mvenv/bin/activate # 配置 ROS2 环境 需要根据自己的系统来配置 source /opt/ros/jazzy/setup.bash # 配置你的工作空间 source ~/chapt4/chapt4_ws/install/setup.bash # 把虚拟环境的 Python 路径加入到 ROS2 的 Python 路径中 后续其他工程或者工作空间的python中需要ros2调用自己创建的虚拟环境的第三方库时直接修该这段中的对应虚拟环境的名词/位置即可 export PYTHONPATH=$PYTHONPATH:/home/robot/mvenv/lib/python3.12/site-packages echo \u0026#34;ROS2 + Python 虚拟环境已配置完成！\u0026#34; 新建功能包ros2 pkg create demo_python_service \u0026ndash;build-type ament_python \u0026ndash;dependencies rclpy chapt4_interfaces \u0026ndash;license Apache-2.0 需要找到一张需要检测的照片放到resource文件夹内，随后更改setup.py文件，表示在colcon build拷贝一份时将source文件下的这张照片也一起拷贝 (\u0026lsquo;share/\u0026rsquo; + package_name+\u0026quot;/resource\u0026quot;, [\u0026lsquo;resource/defult.jpg\u0026rsquo;]), 然后新建learn_face_detect.py，代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os def main(): #获取图片的真实路径 /home/robot/chapt4/chapt4_ws/install/demo_python_service/share/demo_python_service default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;/resource/defult.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 print(f\u0026#34;图片的真实路径：{default_image_path}\u0026#34;) #使用cv2加载图片 image=cv2.imread(default_image_path) #检测人脸 face_locations=face_recognition.face_locations(image,number_of_times_to_upsample=1,model=\u0026#39;hog\u0026#39;) #绘制人脸框 for top,right,bottom,left in face_locations: cv2.rectangle(image,(left,top),(right,bottom),(255,0,0),4) #结果显示 cv2.imshow(\u0026#39;Face Detecte result\u0026#39;,image) cv2.waitKey(0) 然后分别运行,之后再运行ros2 run demo_python_service learn_face_detect source start_mvenv.sh colcon build source install/setup.bash 下面为正式开始人脸检测服务部分： 新建face_detect_node.py代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import rclpy from rclpy.node import Node from chapt4_interfaces.srv import FaceDetector import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os from cv_bridge import CvBridge import time class FaceDetectNode(Node): def __init__(self): super().__init__(\u0026#39;face_detect_node\u0026#39;) self.service_=self.create_service(FaceDetector,\u0026#39;face_detect\u0026#39;,self.detect_face_callback) self.bridge=CvBridge() self.number_of_times_to_upsample=1 self.model=\u0026#39;hog\u0026#39; self.default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;resource/defult.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 self.get_logger().info(f\u0026#34;人脸检测服务成功开启！\u0026#34;) def detect_face_callback(self,request,response): if request.image.data: cv_image=self.bridge.imgmsg_to_cv2(request.image) else: cv_image=cv2.imread(self.default_image_path)#若请求的图片内容为空则识别默认的照片内容，目录位置为上面 self.get_logger().info(f\u0026#34;传入图像为空，使用默认图像！\u0026#34;) #此处的cv_image图像已经是一个opencv格式的图像 start_time=time.time() self.get_logger().info(f\u0026#34;加载完成图像，开始人脸识别！\u0026#34;) face_locations=face_recognition.face_locations(cv_image,number_of_times_to_upsample=self.number_of_times_to_upsample,model=self.model) response.use_time=time.time()-start_time response.number=len(face_locations) #face_locations是一个列表里面其实就是识别出来有多少组人链数组 for top,right,bottom,left in face_locations: response.top.append(top) response.right.append(right) response.bottom.append(bottom) response.left.append(left) return response #必须返回response def main(): rclpy.init() node=FaceDetectNode() rclpy.spin(node) rclpy.shutdown() 之后修改好setup.py然后直接运行即可，打开另外一个终端列出服务：ros2 service list -t，之后再运行service call这个发布的服务消息接口即可，识别出默认的图片内容 人脸检测的客户端实现 现在resource目录下添加好需要识别的照片，然后修改好setup.py在colcon build时将照片也一起拷贝过去 然后正常地新建好face_detect_client_node.py代码示例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import rclpy from rclpy.node import Node from chapt4_interfaces.srv import FaceDetector import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os from cv_bridge import CvBridge import time class FaceDetectClientNode(Node): def __init__(self): super().__init__(\u0026#39;face_detect_client_node\u0026#39;) self.bridge=CvBridge() self.default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;resource/peoples.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 self.get_logger().info(f\u0026#34;人脸检测客户端成功开启！\u0026#34;) self.client=self.create_client(FaceDetector,\u0026#39;face_detect\u0026#39;) self.image=cv2.imread(self.default_image_path) def send_request(self): # 1.判断服务端是否上线 while self.client.wait_for_service(timeout_sec=1.0) is False: self.get_logger().info(f\u0026#34;正在等待服务端上线.....\u0026#34;) # 2.构造Request request=FaceDetector.Request() request.image=self.bridge.cv2_to_imgmsg(self.image) # 3.发送请求并等待处理完成 future=self.client.call_async(request) # while not future.done(): # time.sleep(1.0) #休眠当前线程，等待服务处理完成==造成当前线程无法再接受来自服务端的返回，导致永远无法完成future.done()无法返回True # rclpy.spin_until_future_complete(self,future) #等待服务端返回响应 def result_callback(result_future): response =result_future.result() #获取响应结果 self.get_logger().info(f\u0026#34;接收到响应，共耗时{response.use_time}s,总共检测到{response.number}个人脸\u0026#34;) self.show_response(response) future.add_done_callback(result_callback) def show_response(self,resonse): for i in range(resonse.number): top=resonse.top[i] left=resonse.left[i] right=resonse.right[i] bottom=resonse.bottom[i] cv2.rectangle(self.image,(left,top),(right,bottom),(255,0,0),4) #结果显示 cv2.imshow(\u0026#39;Face Detecte result\u0026#39;,self.image) cv2.waitKey(0)#阻塞 def main(): rclpy.init() node=FaceDetectClientNode() node.send_request() rclpy.spin(node) rclpy.shutdown() 之后正常运行先开始之前的服务端节点，然后再开启客户端节点进行识别既可看到现象 C++小乌龟巡航服务：\n新建服务通讯接口：在srv文件下新建Patrol.srv，内容示例： 1 2 3 4 5 6 float32 target_x float32 target_y --- int8 SUCESS=1 int8 FAIL=0 int8 result # 结果 返回 SUCESS / FAIL 取其中之一 随后更改cmakelist文件将该srv文件路径更新到里面，参考上面python的srv更新。之后直接colcon build已经source既可，查看ros2 interface show chapt4_interface/srv/Patrol 既可看到接口详细信息 (服务端)在src下新建功能包： ros2 pkg create demo_cpp_service \u0026ndash;build-type ament_cmake \u0026ndash;dependencies chapt4_interfaces rclcpp geometry_msgs turtlesim \u0026ndash;license Apache-2.0 随后在项目名称下新建服务端turtle_control.cpp代码示例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: rclcpp::Service\u0026lt;Patrol\u0026gt;::SharedPtr patrol_service_; rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { patrol_service_=this-\u0026gt;create_service\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;,[\u0026amp;](const Patrol::Request::SharedPtr request,Patrol::Response::SharedPtr response)-\u0026gt;void{ if( (0\u0026lt;request-\u0026gt;target_x\u0026amp;\u0026amp;request-\u0026gt;target_x\u0026lt;12.0f)\u0026amp;\u0026amp; (0\u0026lt;request-\u0026gt;target_y\u0026amp;\u0026amp;request-\u0026gt;target_y\u0026lt;12.0f) ) { this-\u0026gt;target_x_=request-\u0026gt;target_x; this-\u0026gt;target_y_=request-\u0026gt;target_y; response-\u0026gt;result=Patrol::Response::SUCESS; } else { response-\u0026gt;result=Patrol::Response::FAIL; } }); publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 之后再cmakelist文件中添加依赖已经需要生成的可执行文件已经拷贝内容3个部分，之后就可以正常地colcon已经source，测试需要开启小海龟节点，可以再开一个rqt可视化工具来发布request服务的接口内容，观察是否能控制小海龟运动既可 (客户端)在src的demo_cpp_service下新建一个patrol_client.cpp，代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026lt;ctime\u0026gt; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; //定义之后可以使用10s,100ms class PatrolClient:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedPtr patrol_client_; public: explicit PatrolClient(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { srand(time(NULL)); //初始化随机数种子 patrol_client_=this-\u0026gt;create_client\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;); timer_=this-\u0026gt;create_wall_timer(10s,[\u0026amp;]()-\u0026gt;void{ //1.检测服务端是否上线 while (!this-\u0026gt;patrol_client_-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中，rclcpp挂了。臣退下了\u0026#34;); return; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;Patrol::Request\u0026gt;(); request-\u0026gt;target_x=rand()%12; request-\u0026gt;target_y=rand()%12; RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;准备好目标点：%f,%f\u0026#34;,request-\u0026gt;target_x,request-\u0026gt;target_y); //3.发送请求 this-\u0026gt;patrol_client_-\u0026gt;async_send_request(request,[\u0026amp;](rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedFuture result_future)-\u0026gt;void{ auto response =result_future.get(); if(response-\u0026gt;result==Patrol::Response::SUCESS) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点成功！\u0026#34;); } if(response-\u0026gt;result==Patrol::Response::FAIL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点失败....\u0026#34;); } }); }); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;PatrolClient\u0026gt;(\u0026#34;patrol_client_node\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 之后修改cmakelist配置文件然后正常地colcon既可，之后正常运行先运行海龟node然后再把服务端的节点开启，最后开启客户端就可以看到小海龟自动动起来了： 参数相关\n参数声明配置 1 2 3 4 5 6 #参数声明 名称＋值 self.declare_parameter(\u0026#39;number_of_times_to_upsample\u0026#39;,1) self.declare_parameter(\u0026#39;model\u0026#39;,\u0026#39;hog\u0026#39;) #参数值获取 self.number_of_times_to_upsample=self.get_parameter(\u0026#39;number_of_times_to_upsample\u0026#39;).value self.model=self.get_parameter(\u0026#39;model\u0026#39;).value 参数使用和更改： 运行节点时可指令更改参数值： ros2 run demo_python_service face_detect_node \u0026ndash;ros-args -p model:=cnn 可在新终端先运行查看当前参数list：ros2 param list 随后可运行类似set参数值：ros2 param set /face_detect_node number_of_times_to_upsample 2 也可以get参数值：ros2 param get /face_detect_node model C++接收参数事件 创建参数并且可以代码内部修改参数值，也可以动态rqt设置参数，通过设置响应设置参数的回调函数来动态设置参数数值并且赋值给代码中的其他参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/set_parameters_result.hpp\u0026#34; using SetParametersResult=rcl_interfaces::msg::SetParametersResult; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: OnSetParametersCallbackHandle::SharedPtr parameter_callback_handle_; rclcpp::Service\u0026lt;Patrol\u0026gt;::SharedPtr patrol_service_; rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { this-\u0026gt;declare_parameter(\u0026#34;k\u0026#34;,1.0); //创建参数 this-\u0026gt;declare_parameter(\u0026#34;max_speed\u0026#34;,1.0); this-\u0026gt;get_parameter(\u0026#34;k\u0026#34;,k_); this-\u0026gt;get_parameter(\u0026#34;max_speed\u0026#34;,max_speed_); this-\u0026gt;set_parameter(rclcpp::Parameter(\u0026#34;k\u0026#34;,2.0)); //内部修改参数 //响应回调函数动态接收参数修改 parameter_callback_handle_=this-\u0026gt;add_on_set_parameters_callback([\u0026amp;] (const std::vector\u0026lt;rclcpp::Parameter\u0026gt; \u0026amp; parameters) -\u0026gt;rcl_interfaces::msg::SetParametersResult{ rcl_interfaces::msg::SetParametersResult result; result.successful = true; for (const auto \u0026amp; parameter : parameters) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;更新参数的值%s=%f\u0026#34;,parameter.get_name().c_str(),parameter.as_double()); if(parameter.get_name()==\u0026#34;k\u0026#34;) { k_=parameter.as_double(); } if(parameter.get_name()==\u0026#34;max_speed\u0026#34;) { max_speed_=parameter.as_double(); } } return result; }); patrol_service_=this-\u0026gt;create_service\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;,[\u0026amp;](const Patrol::Request::SharedPtr request,Patrol::Response::SharedPtr response)-\u0026gt;void{ if( (0\u0026lt;request-\u0026gt;target_x\u0026amp;\u0026amp;request-\u0026gt;target_x\u0026lt;12.0f)\u0026amp;\u0026amp; (0\u0026lt;request-\u0026gt;target_y\u0026amp;\u0026amp;request-\u0026gt;target_y\u0026lt;12.0f) ) { this-\u0026gt;target_x_=request-\u0026gt;target_x; this-\u0026gt;target_y_=request-\u0026gt;target_y; response-\u0026gt;result=Patrol::Response::SUCESS; } else { response-\u0026gt;result=Patrol::Response::FAIL; } }); publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 代码跑通后直接在rqt中parameter reconfigure动态修改节点中的对应设置好的k和max_speed的值，随后查看终端是否打印修改成功信息 C++修改其他节点的参数 分别新建客户端用于发送请求，以及新建更新参数值函数，主函数调用更新参数值函数即可，代码示例中主要是设置k的参数值，如果需要修改其他参数值直接新建设置函数即可，主要如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026lt;ctime\u0026gt; #include \u0026#34;rcl_interfaces/msg/parameter.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/parameter_value.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/parameter_type.hpp\u0026#34; #include \u0026#34;rcl_interfaces/srv/set_parameters.hpp\u0026#34; using SetP=rcl_interfaces::srv::SetParameters; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; //定义之后可以使用10s,100ms class PatrolClient:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedPtr patrol_client_; public: explicit PatrolClient(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { srand(time(NULL)); //初始化随机数种子 patrol_client_=this-\u0026gt;create_client\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;); timer_=this-\u0026gt;create_wall_timer(10s,[\u0026amp;]()-\u0026gt;void{ //1.检测服务端是否上线 while (!this-\u0026gt;patrol_client_-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中，rclcpp挂了。臣退下了\u0026#34;); return; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;Patrol::Request\u0026gt;(); request-\u0026gt;target_x=rand()%12; request-\u0026gt;target_y=rand()%12; RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;准备好目标点：%f,%f\u0026#34;,request-\u0026gt;target_x,request-\u0026gt;target_y); //3.发送请求 this-\u0026gt;patrol_client_-\u0026gt;async_send_request(request,[\u0026amp;](rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedFuture result_future)-\u0026gt;void{ auto response =result_future.get(); if(response-\u0026gt;result==Patrol::Response::SUCESS) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点成功！\u0026#34;); } if(response-\u0026gt;result==Patrol::Response::FAIL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点失败....\u0026#34;); } }); }); } /* * 创建客户端发送请求，并且返回结果 */ SetP::Response::SharedPtr call_set_parameters(const rcl_interfaces::msg::Parameter \u0026amp;param) { auto param_client=this-\u0026gt;create_client\u0026lt;SetP\u0026gt;(\u0026#34;/turtle_control/set_parameters\u0026#34;); //1.检测服务端是否上线 while (!param_client-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待第二个set_param服务上线中，rclcpp挂了。臣退下了\u0026#34;); return nullptr; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;SetP::Request\u0026gt;(); request-\u0026gt;parameters.push_back(param); //3.发送请求 auto furture=param_client-\u0026gt;async_send_request(request); rclcpp::spin_until_future_complete(this-\u0026gt;get_node_base_interface(),furture); auto response=furture.get(); return response; } /* * 更新参数值 */ void update_server_param_k(double k) { //1.创建一个参数对象 auto param=rcl_interfaces::msg::Parameter(); param.name=\u0026#34;k\u0026#34;; //2.创建参数值 auto param_value=rcl_interfaces::msg::ParameterValue(); param_value.type=rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE; param_value.double_value=k; param.value=param_value; //3.请求更新参赛 auto response=this-\u0026gt;call_set_parameters(param); if(response==NULL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回失败\u0026#34;); return; } for(auto result:response-\u0026gt;results) { if(result.successful==false) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回失败，原因是：%s\u0026#34;,result.reason.c_str()); } else{ RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回成功\u0026#34;); } } } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;PatrolClient\u0026gt;(\u0026#34;patrol_client_node\u0026#34;); node-\u0026gt;update_server_param_k(5.0); rclcpp::spin(node); rclcpp::shutdown(); } 写完后编译，先运行上一节的参数声明节点，然后再运行新写的修改参数节点，既可看到终端打印的日志内容是否成功检测到服务上线以及是否修改成功 使用launch文件\n现在想要的功能包下面新建launch文件夹，然后再launch文件夹内新建一个demo.launch.py文件，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import launch import launch_ros def generate_launch_description(): #此函数名是固定的 \u0026#34;\u0026#34;\u0026#34;产生launch描述\u0026#34;\u0026#34;\u0026#34; action_node_turtlesim_node=launch_ros.actions.Node( package=\u0026#39;turtlesim\u0026#39;, executable=\u0026#39;turtlesim_node\u0026#39;, output=\u0026#39;screen\u0026#39; # 输出方式一：屏幕 ) action_node_turtle_control=launch_ros.actions.Node( package=\u0026#39;demo_cpp_service\u0026#39;, executable=\u0026#39;turtle_control\u0026#39;, output=\u0026#39;log\u0026#39; # 输出方式二：日志文件 ) action_node_patrol_client=launch_ros.actions.Node( package=\u0026#39;demo_cpp_service\u0026#39;, executable=\u0026#39;patrol_client\u0026#39;, output=\u0026#39;both\u0026#39; # 输出方式三：上面两种都要 ) return launch.LaunchDescription([ # actions动作 action_node_turtlesim_node, action_node_turtle_control, action_node_patrol_client ]) 随后更改拷贝的构建配置，在C++中的cmakelist文件中添加下面内容指定拷贝的文件夹名称和文件路径即可： 1 2 3 // install(DIRECTORY launch // DESTINATION share/${PROJECT_NAME} // ) 在python中的setup.py中添加下面内容，同样指定文件夹和文件路径： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from setuptools import find_packages, setup from glob import glob # 1.引入此包 package_name = \u0026#39;demo_python_service\u0026#39; setup( name=package_name, version=\u0026#39;0.0.0\u0026#39;, packages=find_packages(exclude=[\u0026#39;test\u0026#39;]), data_files=[ (\u0026#39;share/ament_index/resource_index/packages\u0026#39;, [\u0026#39;resource/\u0026#39; + package_name]), (\u0026#39;share/\u0026#39; + package_name, [\u0026#39;package.xml\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/resource\u0026#34;, [\u0026#39;resource/defult.jpg\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/resource\u0026#34;, [\u0026#39;resource/peoples.jpg\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/launch\u0026#34;, glob(\u0026#39;launch/*.launch.py\u0026#39;)), # 2.添加指定路径以及文件 ], install_requires=[\u0026#39;setuptools\u0026#39;], zip_safe=True, maintainer=\u0026#39;robot\u0026#39;, maintainer_email=\u0026#39;robot@todo.todo\u0026#39;, description=\u0026#39;TODO: Package description\u0026#39;, license=\u0026#39;Apache-2.0\u0026#39;, tests_require=[\u0026#39;pytest\u0026#39;], entry_points={ \u0026#39;console_scripts\u0026#39;: [ \u0026#39;learn_face_detect=demo_python_service.learn_face_detect:main\u0026#39;, \u0026#39;face_detect_node=demo_python_service.face_detect_node:main\u0026#39;, \u0026#39;face_detect_client_node=demo_python_service.face_detect_client_node:main\u0026#39;, ], }, ) 配置好后先colcon build，随后再source完，运行：ros2 launch 功能包名（创建launch文件夹的功能包位置） demo.launch.py 之后就能看到配置的对应节点成功打开 4. 心得总结 移步完这篇笔记内容才算是把我本地电脑上那个“原始人的CMD笔记”给完全移步完😥，也算是逐步纠正自己的拖延症和懒了😩。其实Linux的学习感觉还是有很多实践和操作需要动手边学边运用才能更好吸收，后面更多的还是带入实际项目中去边学边做！还有后面需要的细分在Linux系统下具体做例如音频，网络等等开发再栏，先学习运用在ROS机器人操作系统上的具体例如自主导航，手眼标定抓取等等，一步一步总会找到属于自己想要的🥱🥱🥱\n","date":"2025-10-22T00:00:00Z","image":"https://prominsegsj.github.io/p/ros2_learn/2_hu_10a77e11c215a0af.png","permalink":"https://prominsegsj.github.io/p/ros2_learn/","title":"【ROS2】通讯架构的学习"},{"content":"基于Linux操作系统下的相关学习 (本次学习开发环境都是在虚拟机ubantu24.04.2系统版本以及ROS2的jazzy版本下的记录)本来是想分开来分别记录树莓派跟ROS2的相关学习的，但是想来现在的学习深度和笔记都较为浅，我就暂为放到一起算作总的Linux学习好了🤌🤌\n1. Linux基础终端 ls -a【列出当前文件夹内所有文件，包括隐藏文件】 source +文件名称【运行某个文本文件】 ~/.bashrc【文件是终端运行时会自动提前运行的脚本】 nano 文件名【文件编辑器编辑/创建文件】 gedit 文件名【文件编辑器编辑/创建文件】 whereis 软件名称【查询安装路径】 code ./ 【使用vscode打开当前文件路径文件夹】 mv 原文件名 重命名文件名 【重命名文件名】 查看当前系统版本：lsb_release -a 2. 树莓派学习笔记 其实树莓派就是一个集成的小的硬件\u0026quot;小电脑\u0026quot;，安装好对应的树莓派或者其他操作系统就可以正常开发使用了，对应的个人认为较好的教程可以看b站UP树小溪，整体的环境配置和流程我就不赘述了，详细直接看这个他的视频即可。此处只做个人的学习笔记，仅供参考！补充：本笔记的系统环境是树莓派的官方环境Raspberry Pi OS。\n2.1 初步账号设置 主机：miaochuangbalou 密码：111111 地址：192.168.137.92 【此处是我给树莓派配置的固定ip，详细看教程】 2.2 常用终端指令 终端开启树莓派配置选项：sudo raspi-config 查看当前电脑IP:hostname -I 删除非空目录文件夹：rm -r 文件名 清屏操作：clear 2.3 配置示例代码 代码1：配置树莓派自动开启vnc 例程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/bin/sh export USER=\u0026#39;master\u0026#39; eval cd~$USER case \u0026#34;$1\u0026#34; in start) #启动命令行。此处自定义分辨率、控制台号码或其它参数。 su $USER -c \u0026#39;/usr/bin/vncserver -depth 24 -geometry 1920x1080:1\u0026#39; echo \u0026#34;Starting VNCServer for $USER\u0026#34; ;; stop) su $USER -c \u0026#39;/usr/bin/vncserver -kill:1\u0026#39; echo \u0026#34;VNCServer stopped\u0026#34; ;; *) echo \u0026#34;Usage: /etc/init.d/vncserver {start/stop}\u0026#34; exit 1 ;; esac exit 0 代码2：自动连接热点 例程 1 2 3 4 5 6 7 8 9 10 11 #（wpa_supplicant.conf（文件名）） country=CN ctrl_interface=DIR=/var/run/wpa_supplicant，GROUP=netdev update_config=1 network={ ssid=\u0026#34;WiFi名称\u0026#34; psk=\u0026#34;WiFi密码\u0026#34; key_mgmt=WPA-PSK priority=1 } 2.4 python开发环境配置(venv虚拟环境) 查看当前python版本：python \u0026ndash;version 创建虚拟环境： (1). sudo apt-get update （更新apt工具） (2). sudo apt-get install python3-venv（下载虚拟环境） (3). python3 -m venv venv （先进入想要创建的虚拟环境的文件路径创建虚拟环境，最后为环境名称） (4). source venv/bin/activate （激活虚拟环境） (5). pip list（查看当前环境的python包） (6). deactivate（退出当前的虚拟环境） 创建虚拟环境venv时继承系统的包 方法 1：创建虚拟环境时继承系统包 python3 -m venv \u0026ndash;system-site-packages myenv 解释1：myenv 是你的虚拟环境目录名（可自定义）。 解释2：\u0026ndash;system-site-packages 会让虚拟环境继承系统中已安装的包。 方法 2：对已存在的虚拟环境启用系统包 解释：如果虚拟环境已经创建，但没有继承系统包，可以通过修改虚拟环境的配置文件手动启用. (1). 找到虚拟环境的 pyvenv.cfg 文件（通常在虚拟环境的根目录）： cat myenv/pyvenv.cfg (2). 修改或添加以下行代码内容： include-system-site-packages = true (3). 重新激活虚拟环境即可生效。 2.5 python开发 在 Linux 中，要查看 Python 的 .py 文件内容，可以使用以下几种命令： 使用 cat 命令： cat /path/to/your_python_file.py（cat 命令用于显示文件内容，将会在终端输出整个 .py 文件的内容） 使用 less 命令： less /path/to/your_python_file.py（less 命令可以按页显示文件内容，适用于较大的文件，可以使用箭头键和 PageUp/PageDown 键进行浏览） 使用 more 命令： more /path/to/your_python_file.py（more 命令也可以按页显示文件内容，与 less 类似，但在显示文件内容时的交互方式略有不同） 使用 vim 或 nano 编辑器：(前提是需要先安装好有这个要用的编辑器,一般nano是自带会有的) vim /path/to/your_python_file.py或nano /path/to/your_python_file.py（vim 和 nano 都是文本编辑器，但您也可以使用它们来查看 .py 文件的内容。在 vim 或 nano 中，您可以按 Esc 键退出查看模式，然后输入 :q 命令退出编辑器） 2.6 vim编辑器的使用 初始模式： :w 保存不退出 :q 不保存退出，一般与w搭配:wq保存并退出vim，回到命令行界面 :! 强制性操作，一般与q搭配:!q 为强制退出不保存 / + 文本 查找字符串命令，查找多个匹配结果，可以n键向下查找，N向上查找。 set nu 显示行数。 set nonu 不显示行数 sp + 文件路径 再打开一个窗口，sp表示水平切分窗口，vs表示垂直切分窗口。 v 进入视图模式 i/a 进入编辑模式 视图模式： 上、下、左、右键或者 k（上）、j（下）、h（左）、l（右） 命令进行光标移动并选中文字 选中文本后，d剪切 y复制 p粘贴 x 删除光标所在的单个字符 dd 删除一整行（相当于剪切），p 粘贴 yy 复制单行 u 撤销 Esc按键 退出视图模式回到初始模式 编辑模式： Esc按键 退出视图模式回到初始模式 其他按键则正常输入文本即可 3. ROS2学习笔记 大部分是本人的学习笔记，学习视频主要是鱼香ROS机器人他的知识点和视频内容很详细，真的是在印证\u0026quot;授人以鱼不如授人以渔\u0026quot;。此外还会加上一些个人理解，希望能帮助加深理解，仅供学习参考！\n3.1 ros2 run (1). 命令ros2 run会从一个软件包中启动一个可执行文件： ros2 run \u0026lt;package_name\u0026gt; \u0026lt;executable_name\u0026gt; (2). 解释： eg：要运行turtlesim，请打开一个新的终端，并输入以下命令： ros2 run turtlesim turtlesim_node turtlesim窗口将会打开 这里，包名是 使用 turtlesim ，可执行文件名是 turtlesim_node 然而，我们还不知道节点名称。您可以使用 ros2 node list 命令查找节点名称。 3.2. ros2 node list (1). ros2 node list 命令将显示所有正在运行的节点的名称。当您想与节点进行交互或者系统运行多个节点时需要跟踪它们时，这特别有用。 (2). 解释： (A). 在另一个终端中打开新的终端，同时 turtlesim 仍在运行，请输入以下命令： ros2 node list (B). 终端将返回节点名称： /turtlesim (C). 再打开一个新的终端，并使用以下命令启动 teleop 节点： ros2 run turtlesim turtle_teleop_key 【在这里，我们再次引用了“turtlesim”软件包，但这次我们的目标是名为“turtle_teleop_key”的可执行文件】\n(D). 返回到之前运行ros2 node list的终端，再次运行该命令。你将会看到两个活动节点的名称：\n/turtlesim /teleop_turtle 3.3. 重映射 (1). 重映射：允许你重新分配默认节点属性，如节点名称、话题名称、服务名称等，以自定义的值。在上一个教程中，你在turtle_teleop_key上使用了重映射来改变cmd_vel话题和目标节点为turtle2。 (2). 解释： - (A). 现在，让我们重新分配 /turtlesim 节点的名称。在一个新的终端中运行以下命令： - ros2 run turtlesim turtlesim_node \u0026ndash;ros-args \u0026ndash;remap __node:=my_turtle - (B). 由于您再次调用ros2 run 启动了turtlesim，将会打开另一个turtlesim窗口。但是，现在如果您返回到之前运行ros2 node list的终端，并再次运行该命令，您将看到三个节点名称： - /my_turtle - /turtlesim - /teleop_turtle 3.4. ros2节点信息 (既然您知道了节点的名称，您可以使用以下命令访问有关它们的更多信息)\nros2 node info \u0026lt;node_name\u0026gt; (例). 要查看您最新的节点my_turtle，请运行以下命令： ros2 node info /my_turtle ros2 node info返回订阅者、发布者、服务和动作的列表，即与该节点进行交互的ROS图连接。输出应该如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /my_turtle Subscribers: /parameter_events: rcl_interfaces/msg/ParameterEvent /turtle1/cmd_vel: geometry_msgs/msg/Twist Publishers: /parameter_events: rcl_interfaces/msg/ParameterEvent /rosout: rcl_interfaces/msg/Log /turtle1/color_sensor: turtlesim/msg/Color /turtle1/pose: turtlesim/msg/Pose Service Servers: /clear: std_srvs/srv/Empty /kill: turtlesim/srv/Kill /my_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters /my_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes /my_turtle/get_parameters: rcl_interfaces/srv/GetParameters /my_turtle/list_parameters: rcl_interfaces/srv/ListParameters /my_turtle/set_parameters: rcl_interfaces/srv/SetParameters /my_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically /reset: std_srvs/srv/Empty /spawn: turtlesim/srv/Spawn /turtle1/set_pen: turtlesim/srv/SetPen /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute /turtle1/teleport_relative: turtlesim/srv/TeleportRelative Service Clients: (none) Action Servers: /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute Action Clients: (none) 3.5. 编译运行C++文件 (1). 先在目录下编写CMakeFiles.txt：\n示例： 1 2 3 4 5 6 7 8 9 10 cmake_minimum_required(VERSION 3.8) project(ros2_cpp) add_executable(ros2_cpp_node ros2_cpp_node.cpp) find_package(rclcpp REQUIRED) # 直接查找到对应的头文件和库文件 message(STATUS ${rclcpp_INCLUDE_DIRS}) #头文件及rclcpp依赖的头文件 message(STATUS ${rclcpp_LIBRARIES}) #库文件及rclcpp依赖的库文件 target_include_directories(ros2_cpp_node PUBLIC ${rclcpp_INCLUDE_DIRS}) #头文件包好到ros2_cpp_node文件内 target_link_libraries(ros2_cpp_node ${rclcpp_LIBRARIES}) #库文件链接到ros2_cpp_node文件内 (2). 再在当前目录下运行终端命令：\ncmake . make 【之后会生成一个可以执行文件为绿色的，直接终端输入既可运行】 3.6. 创建功能包 先创建一个工作空间，然后再工作空间下新建src文件夹，进入src文件夹内运行：ros2 pkg create demo_python_topic \u0026ndash;build-type ament_python \u0026ndash;dependencies rclpy example_interfaces \u0026ndash;license Apache-2.0【中间的\u0026ndash;是可选项配置，有编译版本，添加的依赖，许可证，存放目录等等】 然后再回到工作空间文件夹内运行：colcon build (✔️). 启用节点函数 setup.py添加： \u0026lsquo;python_NODE = demo_python_pkg.pyhon_node:main\u0026rsquo;, 【生成可执行文件的名称以及包名和路径，函数名称】 (✔️). 将需要导入的库加入到package.xml功能包清单文件的声明里面导入包，添加依赖信息： 1 \u0026lt;depend\u0026gt;rclpy\u0026lt;/depend\u0026gt; (✔️). 添加完之后需要开启构建功能包：colcon build 【终端直接执行命令，执行完之后是会根据你之前配置的调用函数拷贝复制一份一模一样的.py文件，然后运行调用的是复制过来的文件，不是原来的本身的文件，所以后续写了更新之后它的包调用的是你上一次拷贝的，不是你新写的】 (✔️). 修改环境变量：source install/setup.bash【此文件是创建时生成的】\n或者也可以手动添加这个环境变量： 1 export PYTHONPATH=/home/robot/chapt2/install/demo_python_pkg/lib/python3.12/site-packages:$PYTHONPATH # $PYTHONPATH表示原来的路径不变，缩写，然后加：前面加需要添加的路径 3.7. 其他 (A). echo 🔵查看当前ROS1/ROS2：echo $ROS_VERSION【中间有个下划线】 🔵查看当前ROS版本：echo $ROS_DISTRO (B). 总的打印环境变量信息 🟡printenv 打印特定的信息，进行信息过滤：printenv | grep 想要打印的环境变量 (C). 修改环境变量的文件位置 🟣export 环境变量名称=想要修改的文件位置（仅在当前终端临时修改成效，再另开还是原来的环境位置） (D). 在linux中，以.开头的文件或者文件夹，是隐藏文件 🔴(例). 启动自运行脚本：~/.bashrc (E). 安装python插件在vscode中的代码注释ctrl加左键，或者长放提示的注释形式 (F). 增加可执行文件的执行权限，白色为较低权限，绿色为较高权限可进行执行： 🟠chmod a+x 文件名 (G). 查看节点的具体信息 ⚫ros2 node info /节点名称 打印目标话题的信息 ros2 topic echo 目标话题的名称 查看话题的详细信息 ros2 topic info 目标话题的名称 打印话题的某个接口的详细信息 ros2 interface show 接口名称 发布一个话题 ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist \u0026ldquo;{linear: {x: 0.4, y: 0.0} , angular: {z: 0.0}}\u0026rdquo; 【话题名称＋接口名称＋发布信息】\n打印当前话题列表 ros2 topic list 3.8 工作空间(WorkPlace) 创建使用工作空间 mkdir -p chapt2_ws/src 【-p表示创建目录下的文件夹】 mv demo_cpp_pkg/ chapt2_ws/src/【将要整合的包剪切移动到工作空间下】 mv demo_cpp_pkg/ chapt2_ws/src/ cd chapt2_ws/【进入工作空间再构建主，保证架构的清晰完整】 colcon build 【构建】 如果有功能包的依赖关系需要更改构建顺序就在对应需要依赖的package.xml文件内添加对应的依赖包既可，系统就会先编译构建被依赖的包 被依赖的包名 3.9 Python学习 简单的类和函数以及init方法的理解 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class PersonNode: def __init__(self,name_value:str,age_value:int): print(\u0026#39;PersonNode __init__方法被调用并且还添加了两个属性！\u0026#39;) self.name=name_value self.age=age_value def eat(self,food_name:str): \u0026#34;\u0026#34;\u0026#34; 方法：吃东西 :food_name 食物名字 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) def main(): node = PersonNode(\u0026#39;法外狂徒张三\u0026#39;,20) node2 = PersonNode(\u0026#39;法外狂徒里斯\u0026#39;,19) node.eat(\u0026#39;黄焖鸡米饭\u0026#39;) node2.eat(\u0026#39;鱼香肉丝\u0026#39;) 简单的继承思想 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import rclpy from rclpy.node import Node #倒入Node类 class PersonNode(Node):#此处的Node就是继承于导入的rclpy.node里面的Node类 def __init__(self,node_name:str,name_value:str,age_value:int): print(\u0026#39;PersonNode __init__方法被调用并且还添加了两个属性！\u0026#39;) super().__init__(node_name) #初始化节点 self.name=name_value self.age=age_value def eat(self,food_name:str): \u0026#34;\u0026#34;\u0026#34; 方法：吃东西 :food_name 食物名字 \u0026#34;\u0026#34;\u0026#34; # print(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) self.get_logger().info(f\u0026#34;{self.name},{self.age}岁，爱吃{food_name}！\u0026#34;) #将内容添加到ros日志里面并且打印 def main(): rclpy.init() #使用ros2前需要执行init初始化资源配置 node = PersonNode(\u0026#39;zhangsan_node\u0026#39;,\u0026#39;法外狂徒张三\u0026#39;,20) node.eat(\u0026#39;黄焖鸡米饭\u0026#39;) rclpy.spin(node) #收集节点数据 rclpy.shutdown() #关闭节点 多线程及回调函数 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import threading import requests class Download: def download(sel,url,callback_word_count): print(f\u0026#34;线程：{threading.get_ident()}开始下载：{url}\u0026#34;) response = requests.get(url) response.encoding=\u0026#39;utf-8\u0026#39; #给请求的结果一个编码 callback_word_count(url,response.text) #调用回调函数 #pass def start_download(self,url,callback_word_count): thread = threading.Thread(target=self.download,args=(url,callback_word_count)) #创建一个新的线程 target目标函数，args需要传入的参数 thread.start() #启动线程 # pass def world_count(url,result): \u0026#34;\u0026#34;\u0026#34; 普通的函数，用于回调 \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{url}:{len(result)}-\u0026gt;{result[:5]}\u0026#34;) def main(): download = Download() download.start_download(\u0026#39;url网址\u0026#39;,world_count) download.start_download(\u0026#39;url网址\u0026#39;,world_count) download.start_download(\u0026#39;url网址\u0026#39;,world_count) 3.10 C++学习 C++ vscode的扩展遇到include报错找不到路径就在他扩展配置中添加类似：/opt/ros/jazzy/include/** 依据类似的面向对象编程原理，代码示例如下： 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; // 定义一个PersionNode的类并且继承rclcpp的Node作为父类 class PersonNode : public rclcpp::Node { private: // 声明 std::string name_; int age_; public: PersonNode(const std::string \u0026amp;node_name, const std::string \u0026amp;name, const int \u0026amp;age) : Node(node_name) /*调用父类的构造函数，等同于python中的 super().__init__(),传入节点的名称作为参数*/ { this-\u0026gt;name_ = name; this-\u0026gt;age_ = age; }; void eat(const std::string \u0026amp;food_name) { RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;我是%s,%d岁了,爱吃%s\u0026#34;, this-\u0026gt;name_.c_str(), this-\u0026gt;age_, food_name.c_str()); }; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = std::make_shared\u0026lt;PersonNode\u0026gt;(\u0026#34;persion_node\u0026#34;, \u0026#34;小过\u0026#34;, 20); node-\u0026gt;eat(\u0026#34;黄焖鸡米饭\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); return 0; } 将代码添加到src/目录下创建的person_node.cpp文件内，编写好后再到CmkeList.txt文件内添加指定输出的可执行文件名和需要连接的包名以及执行编译 最终进入到CmkeList.txt目录结构下（例如图片中的目录应进入chart2_ws/）运行 colcon build #编译 source install/setup.bash C++新特性 auto自动类型推导，示例代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;iostream\u0026#34; int main() { //auto 的自动类型推导 auto xn = 2 ; //int xn = 2; auto yn = 3.14f; //float yn = 3.1415; auto zn = \u0026#39;a\u0026#39;;//char zn = \u0026#39;a\u0026#39;; std::cout\u0026lt;\u0026lt;xn\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;yn\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;zn\u0026lt;\u0026lt;std::endl; return 0; } 共享指针 使用共享指针不要用重复新增内存地址，并且可以自动回收不会造成内存泄漏，例如下面的make_shared例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;iostream\u0026#34; #include \u0026#34;memory\u0026#34; int main() { auto p1 = std::make_shared\u0026lt;std::string\u0026gt;(\u0026#34;This is a str.\u0026#34;); // std::make_shared\u0026lt;数据类型/类\u0026gt;（参数）；返回值，对应的共享指针 std::shared_ptr\u0026lt;std::string\u0026gt; 写成 auto std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 1 auto p2 =p1; std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 2 std::cout\u0026lt;\u0026lt;\u0026#34;p2的引用计数\u0026#34;\u0026lt;\u0026lt; p2.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2.get()\u0026lt;\u0026lt;std::endl; // 2 p1.reset(); //释放引用，不指向“This is a str.”所在内存 std::cout\u0026lt;\u0026lt;\u0026#34;p1的引用计数\u0026#34;\u0026lt;\u0026lt; p1.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p1.get()\u0026lt;\u0026lt;std::endl; // 0 std::cout\u0026lt;\u0026lt;\u0026#34;p2的引用计数\u0026#34;\u0026lt;\u0026lt; p2.use_count()\u0026lt;\u0026lt;\u0026#34;,指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2.get()\u0026lt;\u0026lt;std::endl; // 2-1=1 std::cout\u0026lt;\u0026lt;\u0026#34;p2的指向内存地址：\u0026#34;\u0026lt;\u0026lt;p2-\u0026gt;c_str()\u0026lt;\u0026lt;std::endl; // 调用成员方法 This is a str. return 0; } 匿名函数 换一种语法的函数 下面lambda函数示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;iostream\u0026#34; #include \u0026lt;algorithm\u0026gt; int main() { auto add = [](int a,int b) -\u0026gt; int {return a+b;}; int sum = add(200,50); auto print_sum = [sum]() -\u0026gt; void //此处直接将sum内容调用过来 { std::cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;std::endl; }; print_sum(); return 0; } 函数包装器，理解下面示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; // 自由函数 void save_with_free_fun(const std::string \u0026amp;file_name) { std::cout \u0026lt;\u0026lt; \u0026#34;自由函数：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; } // 成员函数 class FileSave { private: public: FileSave(/* args */) = default; ~FileSave() = default; void save_with_member_fun(const std::string \u0026amp;file_name) { std::cout \u0026lt;\u0026lt; \u0026#34;成员方法：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; }; }; int main() { FileSave file_save; // Lambda函数 auto save_with_lambda_fun = [](const std::string \u0026amp;file_name) -\u0026gt; void { std::cout \u0026lt;\u0026lt; \u0026#34;Lambda 函数：\u0026#34; \u0026lt;\u0026lt; file_name \u0026lt;\u0026lt; std::endl; }; //常见的普通函数调用 // save_with_lambda_fun(\u0026#34;file.txt\u0026#34;); // Lambda函数的调用 // file_save.save_with_member_fun(\u0026#34;file.txt\u0026#34;); // 成员函数的调用 // save_with_free_fun(\u0026#34;file.txt\u0026#34;); // 自由函数的调用 //使用函数包装器之后的： std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save1=save_with_free_fun; std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save2=save_with_lambda_fun; //成员函数，放入包装器 std::function\u0026lt;void(const std::string\u0026amp;)\u0026gt; save3=std::bind(\u0026amp;FileSave::save_with_member_fun, \u0026amp;file_save,std::placeholders::_1); //保护类的其他方法不被调用 //统一的调用方法 save1(\u0026#34;file.txt\u0026#34;); save2(\u0026#34;file.txt\u0026#34;); save3(\u0026#34;file.txt\u0026#34;); return 0; } 3.11 多线程以及回调函数 C++具体(有关http服务的请求等部分较为复杂，详细请看ROS2 小鱼) 【打开http服务：python3 -m http.server】 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; //多线程 #include \u0026lt;chrono\u0026gt; //时间相关 #include \u0026lt;functional\u0026gt; //函数包装器 #include \u0026#34;cpp-httplib/httplib.h\u0026#34; //下载相关 class Download { private: /* data */ public: void download(const std::string \u0026amp;host,const std::string \u0026amp;path,const std::function\u0026lt;void(const std::string\u0026amp;,const std::string\u0026amp;)\u0026gt; \u0026amp;callback_word_count) { std::cout\u0026lt;\u0026lt;\u0026#34;线程\u0026#34;\u0026lt;\u0026lt;std::this_thread::get_id()\u0026lt;\u0026lt;std::endl; httplib::Client client(host); auto response=client.Get(path); if(response\u0026amp;\u0026amp;response-\u0026gt;status==200) { callback_word_count(path,response-\u0026gt;body); } }; void start_download(const std::string \u0026amp;host,const std::string \u0026amp;path,const std::function\u0026lt;void(const std::string\u0026amp;,const std::string\u0026amp;)\u0026gt; \u0026amp;callback_word_count) { auto download_fun=std::bind(\u0026amp;Download::download,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3); std::thread thread(download_fun,host,path,callback_word_count); thread.detach(); //线程分离！ }; }; int main() { auto d=Download(); auto word_count =[](const std::string \u0026amp;path,const std::string \u0026amp;result) -\u0026gt;void { std::cout\u0026lt;\u0026lt;\u0026#34;下载完成\u0026#34;\u0026lt;\u0026lt;path\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;result.length()\u0026lt;\u0026lt;\u0026#34;-\u0026gt;\u0026#34;\u0026lt;\u0026lt;result.substr(0,5)\u0026lt;\u0026lt;std::endl; }; d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path1地址\u0026#34;,word_count); d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path2地址\u0026#34;,word_count); d.start_download(\u0026#34;host域名\u0026#34;,\u0026#34;path3地址\u0026#34;,word_count); std::this_thread::sleep_for(std::chrono::milliseconds(1000*100));//休眠10s return 0; } 3.12 话题 话题的发布 示例python节点代码发布话题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import rclpy from rclpy.node import Node import requests from example_interfaces.msg import String from queue import Queue class NovelPuNode(Node): def __init__(self,node_name): super().__init__(node_name) self.get_logger().info(f\u0026#34;{node_name},启动！\u0026#34;) self.novel_queue_=Queue() #创建队列 放在前面 self.novel_publisher_ = self.create_publisher(String,\u0026#39;novel\u0026#39;,10) self.create_timer(5,self.timer_callback) def timer_callback(self): if self.novel_queue_.qsize()\u0026gt;0: line = self.novel_queue_.get() msg=String() #组装 msg.data=line self.novel_publisher_.publish(msg) self.get_logger().info(f\u0026#34;发布了：{msg} 这条信息！\u0026#34;) def download(self,url): response = requests.get(url) #发送开始请求 response.encoding=\u0026#39;utf-8\u0026#39; #给请求的结果一个编码 text =response.text self.get_logger().info(f\u0026#34;下载{url},{len(text)}\u0026#34;) for line in text.splitlines(): #获取到每一行的数据存储到队列中 按行分割 self.novel_queue_.put(line) def main(): rclpy.init() node = NovelPuNode(\u0026#39;novel_pub\u0026#39;) node.download(\u0026#39;http://0.0.0.0:8000/novel1.txt\u0026#39;) rclpy.spin(node) rclpy.shutdown() 订阅话题 python示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import espeakng import rclpy from rclpy.node import Node from example_interfaces.msg import String from queue import Queue import threading import time class NovelSubNode(Node): def __init__(self,node_name): super().__init__(node_name) self.get_logger().info(f\u0026#34;{node_name},启动！\u0026#34;) self.novels_queue_ =Queue() self.novel_subscriber_=self.create_subscription(String,\u0026#39;novel\u0026#39;,self.novel_callback,10) self.speech_thread_ =threading.Thread(target=self.speake_thread) self.speech_thread_.start() def novel_callback(self,msg): self.novels_queue_.put(msg.data) def speake_thread(self): speaker =espeakng.Speaker() speaker.voice=\u0026#39;zh-yue\u0026#39; while rclpy.ok(): #检测当前ROS上下文是否OK if self.novels_queue_.qsize()\u0026gt;0: text =self.novels_queue_.get() self.get_logger().info(f\u0026#39;朗诵：{text}\u0026#39;) speaker.say(text) #说 speaker.wait() #等他说完 else: # 让当前进程休眠1s time.sleep(1) def main(): rclpy.init() node = NovelSubNode(\u0026#39;novel_sub\u0026#39;) rclpy.spin(node) rclpy.shutdown() 安装espeakng过程中遇到的问题：（建议是直接创建一个合适的虚拟环境venv然后下载你后续需要的库，不要用全局系统） 直接先进入到你想要放置虚拟环境的文件中，建议是直接放到~/目录下，然后运行： 1 2 # 使用全局Python创建虚拟环境，并继承系统包 # /bin/python3 -m venv --system-site-packages ~/mvenv 随后在你的vscode中替换为你新建的环境： 之后你缺少哪个库，就在这个虚拟环境下直接：(pip install 库名 ) 既可 最终的编译后使用ros2 run 时需要提前在本工作空间新建一个.sh脚本文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash # 激活虚拟环境 source ~/mvenv/bin/activate # 配置 ROS2 环境 需要根据自己的系统来配置 source /opt/ros/jazzy/setup.bash # 配置你的工作空间 source ~/chapt3/topic_ws/install/setup.bash # 把虚拟环境的 Python 路径加入到 ROS2 的 Python 路径中 后续其他工程或者工作空间的python中需要ros2调用自己创建的虚拟环境的第三方库时直接修该这段中的对应虚拟环境的名词/位置即可 export PYTHONPATH=$PYTHONPATH:/home/robot/mvenv/lib/python3.12/site-packages echo \u0026#34;ROS2 + Python 虚拟环境已配置完成！\u0026#34; 然后正常colcon build和source install/setup.bash既可运行ros2 run C++发布话题控制小海龟运动 示例代码(仅发布话题)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; using namespace std::chrono_literals; class TurtlrCircleNode:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; //创建计时器 rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 public: explicit TurtlrCircleNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtlrCircleNode::timer_callback,this)); } void timer_callback() { auto msg=geometry_msgs::msg::Twist(); msg.linear.x=1.0; msg.angular.z=0.5; publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtlrCircleNode\u0026gt;(\u0026#34;turtle_circle\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 示例代码(订阅加发布话题 控制小海龟到设定的目标点) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: // rclcpp::TimerBase::SharedPtr timer_; //创建计时器 rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 实战话题小项目：获取系统状态并且qt显示，通过ROS通讯实现局域网通讯 第一步：自定义通讯接口 (1). 新建工作空间topic_practice_ws,在新的工作空间中新建src文件夹创建消息接口的功能包 ros2 pkg create status_interfaces \u0026ndash;dependencies builtin_interfaces rosidl_default_generators \u0026ndash;license Apache-2.0 (2). 在生成的工作包中新建msg文件夹新建好自己的的消息接口文件,(命名规则要求为骆驼峰命名，即开头第一个字母为大写,后缀为.msg),SystemStatus.msg 1 2 3 4 5 6 7 8 builtin_interfaces/Time stamp #记录时间辍引入其他功能包的消息接口，注意去除msg文件路径 string host_name # 主机名字 float32 cpu_percent # CPU使用率 float32 memory_percent # 内存使用率 float32 memory_total # 内存总大小 float32 memory_available # 内存剩于量 float32 net_sent # 网络发送数据总量 1MB=1Mb float32 net_recv # 网络数据接受总量 1MB=1Mb (3). 在cmakelist文件中添加一段： -```cpp # cmake 函数，来自rosidl_default_generators 用于将msg等消息将接口定义文件转换成库或者头文件类 rosidl_generators_interfaces{ ${PROJECT_NAME} \u0026ldquo;msg/SystemStatus.msg\u0026rdquo; DEPENDENCIES builtin_interfaces } (4). 再在package.xml文件中添加一行声明应用了其他文件功能包： \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; (5). 回到src同级目录下进行colcon build构建,之后先source install/setup.bash更新一下环境变量，之后可以运行：ros2 interface show status_interfaces/msg/SystemStatus 查看一下接口信息是否正确 第二步：系统信息获取和发布 (1). 先在同一个工作空间下新建一个python功能包 (2). 再新建一个py文件 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import rclpy from status_interfaces.msg import SystemStatus from rclpy.node import Node import psutil #获取系统信息库 import platform class SysStatusPub(Node): def __init__(self,node_name): super().__init__(node_name) self.status_publisher_ =self.create_publisher( SystemStatus,\u0026#39;sys_status\u0026#39;,10 ) self.timer_ =self.create_timer(1.0,self.timer_callback) def timer_callback(self): # builtin_interfaces/Time stamp #记录时间辍引入其他功能包的消息接口，注意去除msg文件路径 # string host_name # 主机名字 # float32 cpu_percent # CPU使用率 # float32 memory_percent # 内存使用率 # float32 memory_total # 内存总大小 # float32 memory_available # 内存剩于量 # float32 net_sent # 网络发送数据总量 1MB=1Mb # float32 net_recv # 网络数据接受总量 1MB=1Mb cpu_percent = psutil.cpu_percent() #cpu当前使用率 memory_info=psutil.virtual_memory() # 内存相关信息 net_io_counters=psutil.net_io_counters() # 网络输入输出相关信息 msg=SystemStatus() msg.stamp=self.get_clock().now().to_msg() msg.host_name=platform.node() msg.cpu_percent=cpu_percent msg.memory_percent=memory_info.percent msg.memory_total=memory_info.total/1024/1024 msg.memory_available=memory_info.available/1024/1024 msg.net_sent=net_io_counters.bytes_sent/1024/1024 msg.net_recv=net_io_counters.bytes_recv/1024/1024 self.get_logger().info(f\u0026#39;发布：{str(msg)}\u0026#39;)#ros信息终端打印信息 self.status_publisher_.publish(msg) #发布信息 def main(): rclpy.init() node=SysStatusPub(\u0026#39;sys_status_pub\u0026#39;) #创建节点 rclpy.spin(node) #spin运行节点 rclpy.shutdown()#运行完之后关闭 (3). 在setup.py文件中加入：\u0026lsquo;sys_status_pub=status_publisher.sys_status_pub:main\u0026rsquo;, (4). 最后colcon build以及source之后运行：ros2 run status_publisher sys_status_pub，之后可以打开另外一个终端source之后运行：ros2 topic echo /sys_status ，打印当前运行的sys_status_pub节点的发布的sys_status话题，此话题发布了电脑状态的msg信息 第三步：在功能包中使用QT (1). 在工作环境的src文件夹内新建status_display功能包，默认是cpp文件类型，需要加载rclcpp和status_interface，然后新建一个hello_qt.cpp文件 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QLabel\u0026gt; #include \u0026lt;QString\u0026gt; int main(int argc,char *argv[]) { QApplication app(argc,argv); QLabel* lable=new QLabel(); QString message=QString::fromStdString(\u0026#34;Hello Qt!\u0026#34;); lable-\u0026gt;setText(message); lable-\u0026gt;show(); app.exec();//执行应用，阻塞代码 return 0; } (2). 再在cmakelist文件中添加下面4行,之后构建运行即可 find_package(Qt5 REQUIRED COMPONENTS Widgets) # 查找库 add_executable(hello_qt src/hello_qt.cpp) # 添加可执行文件 target_link_libraries(hello_qt Qt5::Widgets) # 链接库 install(TARGETS hello_qt DESTINATION lib/${PROJECT_NAME}) # 备份文件 (3). 基于本实战系统状态显示项目，如下新建一个sys_status_display.cpp： 代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;QApplication\u0026gt; #include \u0026lt;QLabel\u0026gt; #include \u0026lt;QString\u0026gt; #include \u0026lt;rclcpp/rclcpp.hpp\u0026gt; #include \u0026lt;status_interfaces/msg/system_status.hpp\u0026gt; using SystemStatus = status_interfaces::msg::SystemStatus; class SysStatusDisplay : public rclcpp::Node { private: /* data */ rclcpp::Subscription\u0026lt;SystemStatus\u0026gt;::SharedPtr subscriber_; QLabel *lable; public: SysStatusDisplay(/* args */) : Node(\u0026#34;sys_status_display\u0026#34;) { lable = new QLabel(); subscriber_ = this-\u0026gt;create_subscription\u0026lt;SystemStatus\u0026gt;(\u0026#34;sys_status\u0026#34;, 10, [\u0026amp;](const SystemStatus::SharedPtr msg) -\u0026gt; void { lable-\u0026gt;setText(get_qstr_from_msg(msg)); }); lable-\u0026gt;setText(get_qstr_from_msg(std::make_shared\u0026lt;SystemStatus\u0026gt;())); lable-\u0026gt;show(); }; // msg.stamp=self.get_clock().now().to_msg() // msg.host_name=platform.node() // msg.cpu_percent=cpu_percent // msg.memory_percent=memory_info.percent // msg.memory_total=memory_info.total/1024/1024 // msg.memory_available=memory_info.available/1024/1024 // msg.net_sent=net_io_counters.bytes_sent/1024/1024 // msg.net_recv=net_io_counters.bytes_recv/1024/1024 QString get_qstr_from_msg(const SystemStatus::SharedPtr msg) { std::stringstream show_str; show_str \u0026lt;\u0026lt;\u0026#34;========系统状态可视化显示工具==========\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 数 据 时 间：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;stamp.sec\u0026lt;\u0026lt;\u0026#34;\\ts\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 主 机 名 字：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;host_name\u0026lt;\u0026lt;\u0026#34;\\ts\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; CPU 使 用 率：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;cpu_percent\u0026lt;\u0026lt;\u0026#34;\\t%\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 使 用 率：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_percent\u0026lt;\u0026lt;\u0026#34;\\t%\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 总 量：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_total\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 内 存 剩 余：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;memory_available\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 网 络 发 送：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;net_sent\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34; 网 络 接 受：\\t\u0026#34;\u0026lt;\u0026lt;msg-\u0026gt;net_recv\u0026lt;\u0026lt;\u0026#34;\\tMB\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;=====================================\u0026#34; ; return QString::fromStdString(show_str.str()); } }; int main(int argc, char *argv[]) { rclcpp::init(argc,argv); QApplication app(argc, argv); auto node=std::make_shared\u0026lt;SysStatusDisplay\u0026gt;(); std::thread spin_thread([\u0026amp;]()-\u0026gt;void{ rclcpp::spin(node); //启动node节点,阻塞代码 }); spin_thread.detach(); app.exec(); // 执行应用，阻塞代码 return 0; } (4). 更改好cmakelist文件内容，链接好库： 1 2 3 4 5 6 add_executable(sys_status_display src/sys_status_display.cpp) # 添加可执行文件 target_link_libraries(sys_status_display Qt5::Widgets) # 链接库 ament_target_dependencies(sys_status_display rclcpp status_interfaces) install(TARGETS hello_qt sys_status_display DESTINATION lib/${PROJECT_NAME} ) # 备份文件 (5). 最后分别运行status_publisher sys_status_pub和status_display sys_status_display 正常看到显示即大功告成！ 3.13 服务 初步认识使用服务：\n示例： 打开小海龟显示节点(记不起来就双tap) ros2 run turtlesim turtlesim_node 之后再打开另外一个终端(ctrl+alt+t)运行下面图片查看服务，查看某个服务消息详情，call启动一个服务消息 ros2 service list -t ros2 interface show turtlesim/srv/Spawn ros2 service call spawn turtlesim/srv/Spawn \u0026ldquo;{x: 1, y: 1}\u0026rdquo; 使用图形化交互界面：rqt 基于服务的参数通信\n服务的一些参数列表展示:ros2 param list 之后可以打印详细的参数介绍信息：ros2 param describe /turtlesim background_r 还可以打印获取当前参数的值：ros2 param get /turtlesim background_r 还可以设置当前参数的值：ros2 param set /turtlesim background_r 255 一般配置多个参数时最快便捷方法是导出yaml参数文件，之后编辑文件中的参数既可，随后运行相应节点时将yaml参数配置文件一起启用配置 导出服务参数为yaml文件： ros2 param dump /turtlesim \u0026gt; turtlesim_param.yaml 查看当前导出的yaml文件 cat turtlesim_param.yaml 启动节点时使用yaml的配置文件： ros2 run turtlesim turtlesim_node \u0026ndash;ros-args \u0026ndash;params-file turtlesim_param.yaml 【其实就是rclcpp.init(argc,argv)时将yaml传入作为初始化参数】 或者是rqt中的动态配置configuration直接调整修改值 自定义服务接口(人脸识别示例)\n新建号chapt4文件下src内新建一个chapt4_interfaces功能包：\nros2 pkg create chapt4_interfaces \u0026ndash;dependencies sensor_msgs rosidl_default_generators \u0026ndash;license Apache-2.0 再在功能包内新建srv服务接口文件夹，在此文件夹内新建FaceDetector.srv文件并且更改cmakelist和package.xml文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sensor_msgs/Image image #人脸图像 --- int16 number #识别到的人脸个数 float32 use_time #识别耗时 int32[] top #人脸在图像中的位置 int32[] right int32[] bottom int32[] left rosidl_generate_interfaces(${PROJECT_NAME} \u0026#34;srv/FaceDetector.srv\u0026#34; DEPENDENCIES sensor_msgs ) \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; 之后切换到src的同级目录下进行colcon build再source install/setup.bash ，最后运行ros2 interface show chapt4_interfaces/srv/FaceDetector 查看是否有对应的服务接口信息既可\n人脸检测python服务通信：(python在mvenv环境下)\n新建一个start_mvenv.sh文件一键配置虚拟环境 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash # 激活虚拟环境 source ~/mvenv/bin/activate # 配置 ROS2 环境 需要根据自己的系统来配置 source /opt/ros/jazzy/setup.bash # 配置你的工作空间 source ~/chapt4/chapt4_ws/install/setup.bash # 把虚拟环境的 Python 路径加入到 ROS2 的 Python 路径中 后续其他工程或者工作空间的python中需要ros2调用自己创建的虚拟环境的第三方库时直接修该这段中的对应虚拟环境的名词/位置即可 export PYTHONPATH=$PYTHONPATH:/home/robot/mvenv/lib/python3.12/site-packages echo \u0026#34;ROS2 + Python 虚拟环境已配置完成！\u0026#34; 新建功能包ros2 pkg create demo_python_service \u0026ndash;build-type ament_python \u0026ndash;dependencies rclpy chapt4_interfaces \u0026ndash;license Apache-2.0 需要找到一张需要检测的照片放到resource文件夹内，随后更改setup.py文件，表示在colcon build拷贝一份时将source文件下的这张照片也一起拷贝 (\u0026lsquo;share/\u0026rsquo; + package_name+\u0026quot;/resource\u0026quot;, [\u0026lsquo;resource/defult.jpg\u0026rsquo;]), 然后新建learn_face_detect.py，代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os def main(): #获取图片的真实路径 /home/robot/chapt4/chapt4_ws/install/demo_python_service/share/demo_python_service default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;/resource/defult.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 print(f\u0026#34;图片的真实路径：{default_image_path}\u0026#34;) #使用cv2加载图片 image=cv2.imread(default_image_path) #检测人脸 face_locations=face_recognition.face_locations(image,number_of_times_to_upsample=1,model=\u0026#39;hog\u0026#39;) #绘制人脸框 for top,right,bottom,left in face_locations: cv2.rectangle(image,(left,top),(right,bottom),(255,0,0),4) #结果显示 cv2.imshow(\u0026#39;Face Detecte result\u0026#39;,image) cv2.waitKey(0) 然后分别运行,之后再运行ros2 run demo_python_service learn_face_detect source start_mvenv.sh colcon build source install/setup.bash 下面为正式开始人脸检测服务部分： 新建face_detect_node.py代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import rclpy from rclpy.node import Node from chapt4_interfaces.srv import FaceDetector import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os from cv_bridge import CvBridge import time class FaceDetectNode(Node): def __init__(self): super().__init__(\u0026#39;face_detect_node\u0026#39;) self.service_=self.create_service(FaceDetector,\u0026#39;face_detect\u0026#39;,self.detect_face_callback) self.bridge=CvBridge() self.number_of_times_to_upsample=1 self.model=\u0026#39;hog\u0026#39; self.default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;resource/defult.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 self.get_logger().info(f\u0026#34;人脸检测服务成功开启！\u0026#34;) def detect_face_callback(self,request,response): if request.image.data: cv_image=self.bridge.imgmsg_to_cv2(request.image) else: cv_image=cv2.imread(self.default_image_path)#若请求的图片内容为空则识别默认的照片内容，目录位置为上面 self.get_logger().info(f\u0026#34;传入图像为空，使用默认图像！\u0026#34;) #此处的cv_image图像已经是一个opencv格式的图像 start_time=time.time() self.get_logger().info(f\u0026#34;加载完成图像，开始人脸识别！\u0026#34;) face_locations=face_recognition.face_locations(cv_image,number_of_times_to_upsample=self.number_of_times_to_upsample,model=self.model) response.use_time=time.time()-start_time response.number=len(face_locations) #face_locations是一个列表里面其实就是识别出来有多少组人链数组 for top,right,bottom,left in face_locations: response.top.append(top) response.right.append(right) response.bottom.append(bottom) response.left.append(left) return response #必须返回response def main(): rclpy.init() node=FaceDetectNode() rclpy.spin(node) rclpy.shutdown() 之后修改好setup.py然后直接运行即可，打开另外一个终端列出服务：ros2 service list -t，之后再运行service call这个发布的服务消息接口即可，识别出默认的图片内容 人脸检测的客户端实现 现在resource目录下添加好需要识别的照片，然后修改好setup.py在colcon build时将照片也一起拷贝过去 然后正常地新建好face_detect_client_node.py代码示例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import rclpy from rclpy.node import Node from chapt4_interfaces.srv import FaceDetector import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory #导入功能包share目录绝对路径 import os from cv_bridge import CvBridge import time class FaceDetectClientNode(Node): def __init__(self): super().__init__(\u0026#39;face_detect_client_node\u0026#39;) self.bridge=CvBridge() self.default_image_path=os.path.join(get_package_share_directory(\u0026#39;demo_python_service\u0026#39;),\u0026#39;resource/peoples.jpg\u0026#39;)#os库自动判断连接路径是否需要/链接 self.get_logger().info(f\u0026#34;人脸检测客户端成功开启！\u0026#34;) self.client=self.create_client(FaceDetector,\u0026#39;face_detect\u0026#39;) self.image=cv2.imread(self.default_image_path) def send_request(self): # 1.判断服务端是否上线 while self.client.wait_for_service(timeout_sec=1.0) is False: self.get_logger().info(f\u0026#34;正在等待服务端上线.....\u0026#34;) # 2.构造Request request=FaceDetector.Request() request.image=self.bridge.cv2_to_imgmsg(self.image) # 3.发送请求并等待处理完成 future=self.client.call_async(request) # while not future.done(): # time.sleep(1.0) #休眠当前线程，等待服务处理完成==造成当前线程无法再接受来自服务端的返回，导致永远无法完成future.done()无法返回True # rclpy.spin_until_future_complete(self,future) #等待服务端返回响应 def result_callback(result_future): response =result_future.result() #获取响应结果 self.get_logger().info(f\u0026#34;接收到响应，共耗时{response.use_time}s,总共检测到{response.number}个人脸\u0026#34;) self.show_response(response) future.add_done_callback(result_callback) def show_response(self,resonse): for i in range(resonse.number): top=resonse.top[i] left=resonse.left[i] right=resonse.right[i] bottom=resonse.bottom[i] cv2.rectangle(self.image,(left,top),(right,bottom),(255,0,0),4) #结果显示 cv2.imshow(\u0026#39;Face Detecte result\u0026#39;,self.image) cv2.waitKey(0)#阻塞 def main(): rclpy.init() node=FaceDetectClientNode() node.send_request() rclpy.spin(node) rclpy.shutdown() 之后正常运行先开始之前的服务端节点，然后再开启客户端节点进行识别既可看到现象 C++小乌龟巡航服务：\n新建服务通讯接口：在srv文件下新建Patrol.srv，内容示例： 1 2 3 4 5 6 float32 target_x float32 target_y --- int8 SUCESS=1 int8 FAIL=0 int8 result # 结果 返回 SUCESS / FAIL 取其中之一 随后更改cmakelist文件将该srv文件路径更新到里面，参考上面python的srv更新。之后直接colcon build已经source既可，查看ros2 interface show chapt4_interface/srv/Patrol 既可看到接口详细信息 (服务端)在src下新建功能包： ros2 pkg create demo_cpp_service \u0026ndash;build-type ament_cmake \u0026ndash;dependencies chapt4_interfaces rclcpp geometry_msgs turtlesim \u0026ndash;license Apache-2.0 随后在项目名称下新建服务端turtle_control.cpp代码示例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: rclcpp::Service\u0026lt;Patrol\u0026gt;::SharedPtr patrol_service_; rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { patrol_service_=this-\u0026gt;create_service\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;,[\u0026amp;](const Patrol::Request::SharedPtr request,Patrol::Response::SharedPtr response)-\u0026gt;void{ if( (0\u0026lt;request-\u0026gt;target_x\u0026amp;\u0026amp;request-\u0026gt;target_x\u0026lt;12.0f)\u0026amp;\u0026amp; (0\u0026lt;request-\u0026gt;target_y\u0026amp;\u0026amp;request-\u0026gt;target_y\u0026lt;12.0f) ) { this-\u0026gt;target_x_=request-\u0026gt;target_x; this-\u0026gt;target_y_=request-\u0026gt;target_y; response-\u0026gt;result=Patrol::Response::SUCESS; } else { response-\u0026gt;result=Patrol::Response::FAIL; } }); publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 之后再cmakelist文件中添加依赖已经需要生成的可执行文件已经拷贝内容3个部分，之后就可以正常地colcon已经source，测试需要开启小海龟节点，可以再开一个rqt可视化工具来发布request服务的接口内容，观察是否能控制小海龟运动既可 (客户端)在src的demo_cpp_service下新建一个patrol_client.cpp，代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026lt;ctime\u0026gt; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; //定义之后可以使用10s,100ms class PatrolClient:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedPtr patrol_client_; public: explicit PatrolClient(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { srand(time(NULL)); //初始化随机数种子 patrol_client_=this-\u0026gt;create_client\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;); timer_=this-\u0026gt;create_wall_timer(10s,[\u0026amp;]()-\u0026gt;void{ //1.检测服务端是否上线 while (!this-\u0026gt;patrol_client_-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中，rclcpp挂了。臣退下了\u0026#34;); return; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;Patrol::Request\u0026gt;(); request-\u0026gt;target_x=rand()%12; request-\u0026gt;target_y=rand()%12; RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;准备好目标点：%f,%f\u0026#34;,request-\u0026gt;target_x,request-\u0026gt;target_y); //3.发送请求 this-\u0026gt;patrol_client_-\u0026gt;async_send_request(request,[\u0026amp;](rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedFuture result_future)-\u0026gt;void{ auto response =result_future.get(); if(response-\u0026gt;result==Patrol::Response::SUCESS) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点成功！\u0026#34;); } if(response-\u0026gt;result==Patrol::Response::FAIL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点失败....\u0026#34;); } }); }); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;PatrolClient\u0026gt;(\u0026#34;patrol_client_node\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 之后修改cmakelist配置文件然后正常地colcon既可，之后正常运行先运行海龟node然后再把服务端的节点开启，最后开启客户端就可以看到小海龟自动动起来了： 参数相关\n参数声明配置 1 2 3 4 5 6 #参数声明 名称＋值 self.declare_parameter(\u0026#39;number_of_times_to_upsample\u0026#39;,1) self.declare_parameter(\u0026#39;model\u0026#39;,\u0026#39;hog\u0026#39;) #参数值获取 self.number_of_times_to_upsample=self.get_parameter(\u0026#39;number_of_times_to_upsample\u0026#39;).value self.model=self.get_parameter(\u0026#39;model\u0026#39;).value 参数使用和更改： 运行节点时可指令更改参数值： ros2 run demo_python_service face_detect_node \u0026ndash;ros-args -p model:=cnn 可在新终端先运行查看当前参数list：ros2 param list 随后可运行类似set参数值：ros2 param set /face_detect_node number_of_times_to_upsample 2 也可以get参数值：ros2 param get /face_detect_node model C++接收参数事件 创建参数并且可以代码内部修改参数值，也可以动态rqt设置参数，通过设置响应设置参数的回调函数来动态设置参数数值并且赋值给代码中的其他参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;geometry_msgs/msg/twist.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;turtlesim/msg/pose.hpp\u0026#34; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/set_parameters_result.hpp\u0026#34; using SetParametersResult=rcl_interfaces::msg::SetParametersResult; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; class TurtrlControlNode:public rclcpp::Node { private: OnSetParametersCallbackHandle::SharedPtr parameter_callback_handle_; rclcpp::Service\u0026lt;Patrol\u0026gt;::SharedPtr patrol_service_; rclcpp::Publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;::SharedPtr publisher_; //发布者的智能指针 rclcpp::Subscription\u0026lt;turtlesim::msg::Pose\u0026gt;::SharedPtr subscription_;//訂閱者的智能指針 double target_x_{1.0};//目標位置x座標 double target_y_{1.0}; //目標位置y座標 double k_{1.0}; // 比例係數 double max_speed_{3.0}; //最大速度 public: explicit TurtrlControlNode(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { this-\u0026gt;declare_parameter(\u0026#34;k\u0026#34;,1.0); //创建参数 this-\u0026gt;declare_parameter(\u0026#34;max_speed\u0026#34;,1.0); this-\u0026gt;get_parameter(\u0026#34;k\u0026#34;,k_); this-\u0026gt;get_parameter(\u0026#34;max_speed\u0026#34;,max_speed_); this-\u0026gt;set_parameter(rclcpp::Parameter(\u0026#34;k\u0026#34;,2.0)); //内部修改参数 //响应回调函数动态接收参数修改 parameter_callback_handle_=this-\u0026gt;add_on_set_parameters_callback([\u0026amp;] (const std::vector\u0026lt;rclcpp::Parameter\u0026gt; \u0026amp; parameters) -\u0026gt;rcl_interfaces::msg::SetParametersResult{ rcl_interfaces::msg::SetParametersResult result; result.successful = true; for (const auto \u0026amp; parameter : parameters) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;更新参数的值%s=%f\u0026#34;,parameter.get_name().c_str(),parameter.as_double()); if(parameter.get_name()==\u0026#34;k\u0026#34;) { k_=parameter.as_double(); } if(parameter.get_name()==\u0026#34;max_speed\u0026#34;) { max_speed_=parameter.as_double(); } } return result; }); patrol_service_=this-\u0026gt;create_service\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;,[\u0026amp;](const Patrol::Request::SharedPtr request,Patrol::Response::SharedPtr response)-\u0026gt;void{ if( (0\u0026lt;request-\u0026gt;target_x\u0026amp;\u0026amp;request-\u0026gt;target_x\u0026lt;12.0f)\u0026amp;\u0026amp; (0\u0026lt;request-\u0026gt;target_y\u0026amp;\u0026amp;request-\u0026gt;target_y\u0026lt;12.0f) ) { this-\u0026gt;target_x_=request-\u0026gt;target_x; this-\u0026gt;target_y_=request-\u0026gt;target_y; response-\u0026gt;result=Patrol::Response::SUCESS; } else { response-\u0026gt;result=Patrol::Response::FAIL; } }); publisher_=this-\u0026gt;create_publisher\u0026lt;geometry_msgs::msg::Twist\u0026gt;(\u0026#34;/turtle1/cmd_vel\u0026#34;,10); // timer_=this-\u0026gt;create_wall_timer(1000ms,std::bind(\u0026amp;TurtrlControlNode::timer_callback,this)); subscription_=this-\u0026gt;create_subscription\u0026lt;turtlesim::msg::Pose\u0026gt;(\u0026#34;/turtle1/pose\u0026#34;,10,std::bind(\u0026amp;TurtrlControlNode::on_pose_recevied,this,std::placeholders::_1)); } void on_pose_recevied(const turtlesim::msg::Pose::SharedPtr pose) //參數：收到數據的共享指針 { //1.獲取當前位置 auto current_x=pose-\u0026gt;x; auto current_y=pose-\u0026gt;y; RCLCPP_INFO(get_logger(),\u0026#34;當前的：x=%f,y=%f\u0026#34;,current_x,current_y); //2.計算當前的位置和目標位置的距離和朝向的差 auto distance=std::sqrt( (target_x_-current_x)*(target_x_-current_x)+ (target_y_-current_y)*(target_y_-current_y) ); auto angle= std::atan2((target_y_-current_y),(target_x_-current_x)) - pose-\u0026gt;theta; //3.利用角度差和位置差輸出控制 auto msg=geometry_msgs::msg::Twist(); if(distance\u0026gt;0.2) { if(fabs(angle)\u0026gt;0.2) { msg.angular.z=fabs(angle); } else { msg.linear.x=k_*distance; } } //4.限制線速度最大值 if(msg.linear.x\u0026gt;max_speed_) { msg.linear.x=max_speed_; } publisher_-\u0026gt;publish(msg); } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;TurtrlControlNode\u0026gt;(\u0026#34;turtle_control\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); } 代码跑通后直接在rqt中parameter reconfigure动态修改节点中的对应设置好的k和max_speed的值，随后查看终端是否打印修改成功信息 C++修改其他节点的参数 分别新建客户端用于发送请求，以及新建更新参数值函数，主函数调用更新参数值函数即可，代码示例中主要是设置k的参数值，如果需要修改其他参数值直接新建设置函数即可，主要如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026lt;chrono\u0026gt; #include \u0026#34;chapt4_interfaces/srv/patrol.hpp\u0026#34; #include \u0026lt;ctime\u0026gt; #include \u0026#34;rcl_interfaces/msg/parameter.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/parameter_value.hpp\u0026#34; #include \u0026#34;rcl_interfaces/msg/parameter_type.hpp\u0026#34; #include \u0026#34;rcl_interfaces/srv/set_parameters.hpp\u0026#34; using SetP=rcl_interfaces::srv::SetParameters; using Patrol=chapt4_interfaces::srv::Patrol; using namespace std::chrono_literals; //定义之后可以使用10s,100ms class PatrolClient:public rclcpp::Node { private: rclcpp::TimerBase::SharedPtr timer_; rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedPtr patrol_client_; public: explicit PatrolClient(const std::string \u0026amp;node_name):Node(node_name) //加入explicit关键字是防止类进行单参数隐式转换 此处只有一个参数可以被直接使用赋值构造，但是不要允许这样发生，提高代码的可维护性 { srand(time(NULL)); //初始化随机数种子 patrol_client_=this-\u0026gt;create_client\u0026lt;Patrol\u0026gt;(\u0026#34;patrol\u0026#34;); timer_=this-\u0026gt;create_wall_timer(10s,[\u0026amp;]()-\u0026gt;void{ //1.检测服务端是否上线 while (!this-\u0026gt;patrol_client_-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中，rclcpp挂了。臣退下了\u0026#34;); return; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;Patrol::Request\u0026gt;(); request-\u0026gt;target_x=rand()%12; request-\u0026gt;target_y=rand()%12; RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;准备好目标点：%f,%f\u0026#34;,request-\u0026gt;target_x,request-\u0026gt;target_y); //3.发送请求 this-\u0026gt;patrol_client_-\u0026gt;async_send_request(request,[\u0026amp;](rclcpp::Client\u0026lt;Patrol\u0026gt;::SharedFuture result_future)-\u0026gt;void{ auto response =result_future.get(); if(response-\u0026gt;result==Patrol::Response::SUCESS) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点成功！\u0026#34;); } if(response-\u0026gt;result==Patrol::Response::FAIL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;请求巡逻目标点失败....\u0026#34;); } }); }); } /* * 创建客户端发送请求，并且返回结果 */ SetP::Response::SharedPtr call_set_parameters(const rcl_interfaces::msg::Parameter \u0026amp;param) { auto param_client=this-\u0026gt;create_client\u0026lt;SetP\u0026gt;(\u0026#34;/turtle_control/set_parameters\u0026#34;); //1.检测服务端是否上线 while (!param_client-\u0026gt;wait_for_service(1s)) { if(!rclcpp::ok()) { RCLCPP_ERROR(this-\u0026gt;get_logger(),\u0026#34;等待第二个set_param服务上线中，rclcpp挂了。臣退下了\u0026#34;); return nullptr; } RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;等待服务上线中......\u0026#34;); } //2.构造请求的对象 auto request=std::make_shared\u0026lt;SetP::Request\u0026gt;(); request-\u0026gt;parameters.push_back(param); //3.发送请求 auto furture=param_client-\u0026gt;async_send_request(request); rclcpp::spin_until_future_complete(this-\u0026gt;get_node_base_interface(),furture); auto response=furture.get(); return response; } /* * 更新参数值 */ void update_server_param_k(double k) { //1.创建一个参数对象 auto param=rcl_interfaces::msg::Parameter(); param.name=\u0026#34;k\u0026#34;; //2.创建参数值 auto param_value=rcl_interfaces::msg::ParameterValue(); param_value.type=rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE; param_value.double_value=k; param.value=param_value; //3.请求更新参赛 auto response=this-\u0026gt;call_set_parameters(param); if(response==NULL) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回失败\u0026#34;); return; } for(auto result:response-\u0026gt;results) { if(result.successful==false) { RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回失败，原因是：%s\u0026#34;,result.reason.c_str()); } else{ RCLCPP_INFO(this-\u0026gt;get_logger(),\u0026#34;参数返回成功\u0026#34;); } } } }; int main(int argc,char* argv[]) { rclcpp::init(argc,argv); auto node =std::make_shared\u0026lt;PatrolClient\u0026gt;(\u0026#34;patrol_client_node\u0026#34;); node-\u0026gt;update_server_param_k(5.0); rclcpp::spin(node); rclcpp::shutdown(); } 写完后编译，先运行上一节的参数声明节点，然后再运行新写的修改参数节点，既可看到终端打印的日志内容是否成功检测到服务上线以及是否修改成功 使用launch文件\n现在想要的功能包下面新建launch文件夹，然后再launch文件夹内新建一个demo.launch.py文件，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import launch import launch_ros def generate_launch_description(): #此函数名是固定的 \u0026#34;\u0026#34;\u0026#34;产生launch描述\u0026#34;\u0026#34;\u0026#34; action_node_turtlesim_node=launch_ros.actions.Node( package=\u0026#39;turtlesim\u0026#39;, executable=\u0026#39;turtlesim_node\u0026#39;, output=\u0026#39;screen\u0026#39; # 输出方式一：屏幕 ) action_node_turtle_control=launch_ros.actions.Node( package=\u0026#39;demo_cpp_service\u0026#39;, executable=\u0026#39;turtle_control\u0026#39;, output=\u0026#39;log\u0026#39; # 输出方式二：日志文件 ) action_node_patrol_client=launch_ros.actions.Node( package=\u0026#39;demo_cpp_service\u0026#39;, executable=\u0026#39;patrol_client\u0026#39;, output=\u0026#39;both\u0026#39; # 输出方式三：上面两种都要 ) return launch.LaunchDescription([ # actions动作 action_node_turtlesim_node, action_node_turtle_control, action_node_patrol_client ]) 随后更改拷贝的构建配置，在C++中的cmakelist文件中添加下面内容指定拷贝的文件夹名称和文件路径即可： 1 2 3 // install(DIRECTORY launch // DESTINATION share/${PROJECT_NAME} // ) 在python中的setup.py中添加下面内容，同样指定文件夹和文件路径： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from setuptools import find_packages, setup from glob import glob # 1.引入此包 package_name = \u0026#39;demo_python_service\u0026#39; setup( name=package_name, version=\u0026#39;0.0.0\u0026#39;, packages=find_packages(exclude=[\u0026#39;test\u0026#39;]), data_files=[ (\u0026#39;share/ament_index/resource_index/packages\u0026#39;, [\u0026#39;resource/\u0026#39; + package_name]), (\u0026#39;share/\u0026#39; + package_name, [\u0026#39;package.xml\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/resource\u0026#34;, [\u0026#39;resource/defult.jpg\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/resource\u0026#34;, [\u0026#39;resource/peoples.jpg\u0026#39;]), (\u0026#39;share/\u0026#39; + package_name+\u0026#34;/launch\u0026#34;, glob(\u0026#39;launch/*.launch.py\u0026#39;)), # 2.添加指定路径以及文件 ], install_requires=[\u0026#39;setuptools\u0026#39;], zip_safe=True, maintainer=\u0026#39;robot\u0026#39;, maintainer_email=\u0026#39;robot@todo.todo\u0026#39;, description=\u0026#39;TODO: Package description\u0026#39;, license=\u0026#39;Apache-2.0\u0026#39;, tests_require=[\u0026#39;pytest\u0026#39;], entry_points={ \u0026#39;console_scripts\u0026#39;: [ \u0026#39;learn_face_detect=demo_python_service.learn_face_detect:main\u0026#39;, \u0026#39;face_detect_node=demo_python_service.face_detect_node:main\u0026#39;, \u0026#39;face_detect_client_node=demo_python_service.face_detect_client_node:main\u0026#39;, ], }, ) 配置好后先colcon build，随后再source完，运行：ros2 launch 功能包名（创建launch文件夹的功能包位置） demo.launch.py 之后就能看到配置的对应节点成功打开 4. 心得总结 移步完这篇笔记内容才算是把我本地电脑上那个“原始人的CMD笔记”给完全移步完😥，也算是逐步纠正自己的拖延症和懒了😩。其实Linux的学习感觉还是有很多实践和操作需要动手边学边运用才能更好吸收，后面更多的还是带入实际项目中去边学边做！还有后面需要的细分在Linux系统下具体做例如音频，网络等等开发再栏，先学习运用在ROS机器人操作系统上的具体例如自主导航，手眼标定抓取等等，一步一步总会找到属于自己想要的🥱🥱🥱\n","date":"2025-09-13T00:00:00Z","image":"https://prominsegsj.github.io/p/linux_learn/2_hu_10a77e11c215a0af.png","permalink":"https://prominsegsj.github.io/p/linux_learn/","title":"【Linux】操作系统的学习"},{"content":"Github的Git使用学习笔记 小锅的Git使用笔记记录🫠(与“【Windos系统】CMD学习使用”笔记一同挪过来的🦊)\n1. 常用基础 Git初始化：git init（需要再对应文件目录下初始化） 查看Git仓库状态：git status 将文件放到中转存储区：git add ＋文件名(git add . (意思是将当前文件中的所有文件添加到暂存区)) 提交到仓库：git commit（只会提交暂存区的文件也就是标绿的文件，红色文件是还未被放到暂存区的文件不会被提交） 改文件名：mv＋要改的文件＋要改为的名字 批量将文件放到暂存区：add *.文件格式 查看提交仓库记录：git log 回退版本命令：git reset \u0026ndash;三种模式 查看当前分支情况：git branch 新建分支：git branch 分支名 切换到其他分支：git checkout 分支名 新建加切换一步到位：git checkout -b 分支名 合并到主分支上：git merge 需要合并的分支名 删除分支：git branch -d 分支名（-D则为强制删除） 给当前开发代码状态加上标签：git tag 标签名（例如：V1.0） 切换到想要切换的标签状态：git checkout 标签名 2. 提交并且上传到github仓库上大致流程 2.1 首次提交大致流程 ↘️ 1.在需要提交文件目录下打开git brash\n↘️ 2.git init（初始化文件夹为git管理）\n↘️ 3.git add 文件/.（将需要提交到仓库的文件放到暂存区）\n↘️ 4.git commit -m \u0026ldquo;(此次提交记录的备注)\u0026quot;\n↘️ 5.git branch（检查当前所处分支）\n↘️ 6.git remote add origin 仓库ssh地址（创建一个名为origin的远程仓库并且与github上的指定仓库连接）\n↘️ 7.git push -u origin main （最后将当前main分支的已commit的部分push到远程仓库origin上即上传到github上）\n2.2 疑难问题 问题1:后续第二次等的提交注意 重点在后续版本的提交时或者多人开发时应该先：git pull origin main （在提交之前习惯性需要先更新本地仓库跟远程仓库同步，记住是在commit之前同步，不然会报错）即使简单的遇到历史提交不匹配问题，也可以直接执行：git pull 进行合并更新 问题2:删除空的 origin（可选） (例). git remote remove origin 问题3:强制推送： (例). git push -f origin main 3. 心得总结 此篇也是在我之前的那篇TXT文件里面藏着的原始人笔记，我想给他隔开来单独作为Git学习的笔记记录。Github作为全球最大的开源平台还是很多地方可以学习，有海量的全球优秀的开源作品，不管是自己学习用还是做项目都应该学习如何使用和管理自己的项目。开源的思想我认为也是非常棒的觉悟思想(听说好像要整改被微软收购，后面风向会不会变也不知道，但是感觉大方向的开源核心应该是不会变的呢🧐)。作为向更多更优秀的人学习的一项必备技能，希望大家(重点Q自己)要好好学习，要努力提升自己！😎\n","date":"2025-09-11T00:00:00Z","image":"https://prominsegsj.github.io/p/git_learn/1_hu_5f2d8854557f7f45.png","permalink":"https://prominsegsj.github.io/p/git_learn/","title":"【GitHub】基础学习"},{"content":"Windos系统下的cmd 小锅的windos终端使用记录😇(扩展后续了解学习使用PowerShell)\n1. 开启普通终端CMD win＋R 键然后输入cmd指令开启终端窗口\n2. 常用的终端操作 删除： (1). 删除文件夹： rmdir＋文件夹名（注意和del区分） 或者 rd 文件名 /s（反馈选择是否删除非空文件） 或者 rd 文件名 /q （不会反馈任何信息，安静删除） (2). 删除文件：del＋文件 获取时间 (1). 打印当前日期：date (2). 打印当前具体时间：time 复制·剪切 (1). 复制文件夹：copy 要复制的文件 对应的文件夹（只能复制文件，不能复制文件夹xcopy） (2). 剪切文件夹：move 要剪切的文件夹 到哪个文件夹的位置 回声操作： echo 打印文件夹内容： dir 转换文件夹位置：文件夹名: (此处后面要的冒号要记得加) 跳转文件夹位置： cd 打开文件夹图形界面： start 创建文件夹： mkdir or md 文件名 访问从不同文件夹的东西：dir 起始文件夹\\要打印的文件夹 重命名：ren 原文件名 重命名后的文件名 清屏终端之前的操作：cls 3. 小开关 显示指令的功能以及如何使用对应指令：指令＋/？ 显示所有文件夹包括隐藏文件：dir＋/a 循环往复的小开关：指令＋/s＋文件或者其他操作 改变变量： (例) path＝“path”；文件路径 定向输出：需要输出的内容＋＞要输出的文件 (＞＞是删除内容的输出.如果定向输出到nul处则不会有任何显示，意思是倒入垃圾桶) 打开文本文件：type＋文件 定向输入： (例) more＋＜加文件（按页面内容吗一页一页显示） 接力符：| (例) tasklist | more 打开计算器：calc 了解所有进程：tasklist 结束某个进程：taskkill /f /pid 序号 打开浏览器：start msedge 4. 创建txt文本文件 (1).echo. \u0026gt;文件名.txt (2).copy nul 文件名.txt (3).type nul \u0026gt; 文件名.txt（或者建其他文件格式都是这样） 5. 进程管理命令 tasklist #显示计算机上运行的进程列表。 tasklist /V #显示详细任务信息。 taskkill #按照进程ID（PID）或映像名称终止任务。 taskkill /PID 1024 #停止PID=1024 的进程。 taskkill /IM capiws.exe #停止名称为capiws的进程。 taskkill /F /PID 1024 #强制终止进程。 6. 用户管理命令 net user #windows账户管理工具。 net user guest #列出guest账户的信息。 net user hacker 123456 /add #添加账户。 net user hacker 888888 #修改密码。 net user hacker /active:yes|no #启用|禁用账户。 net user hacker /delete #删除账户。 7. 网络管理命令 ipconfig #显示网络配置信息。 ipconfig /all #显示完整配置信息。 ipconfig /displaydns #显示DNS缓存。 ipconfig /flushdns #清理DNS缓存。 番外Tip篇 ollama跑8b模型：(好像是DS热门那会儿我试了一下本地部署DS，没办法电脑性能不行，带不动多好的模型，所以只能玩一玩这个8b的超笨模型😂，相关教程可以b站搜索：ollama本地部署DS，我就不补充配置了。权当做笔记记录使用了😜) (例). ollama run deepseek-r1:8b 8. 心得总结 windos的cmd终端的使用开发还是仅限于上述的基础部分的运用，还有很多功能和使用没有\u0026quot;用到\u0026quot;，等后续有新的使用技巧我再更新做笔记上去(ps:实则是因为自己太懒🙂‍↕️🙂‍↕️，只能算一个学习笔记记录吧，把我的那篇原始人的TXT笔记挪过来啦😅)！!\n","date":"2025-09-11T00:00:00Z","image":"https://prominsegsj.github.io/p/windos_cmd_learn/3_hu_c53d1c5fe612bf14.jpg","permalink":"https://prominsegsj.github.io/p/windos_cmd_learn/","title":"【Windos系统】CMD学习使用"},{"content":"YOLO视觉学习 ↪︎初步接触深度学习视觉检测，主要为学习YOLOV8为初步入门使用教程学习🫣\n1. 环境配置 (发现基本上的学习历程大部分都卡在了环境搭建😭，所以我尽量把环境搭建的细节和流程写详细一点！)\n1.1 安装miniconda 安装miniconda版本为py38windos版本:\n🔹https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/\n【主要用于虚拟环境的配置，在python开发中都可以用的到】\n1.2 虚拟环境搭建 (1) 在conda终端中新建一个名为yolov8的虚拟环境，指定python版本为3.8：conda create -n yolov8 python=3.8【指定python版本位3.8版本】\n(2) 激活/切换到yolov8虚拟环境：conda activate yolov8（虚拟环境名称）\n1.3 镜像源配置(主要是方便本地下载) pypi配置国内清华镜像：（替换为长期，就是将你以后的pip安装下载的通道改为从国内的镜像来下载，大部分的库或者安装都是在国外网站，下载比较慢，所以替换镜像为清华源，还有其他的类似的阿里等等）\n🔹https://mirrors.tuna.tsinghua.edu.cn/help/pypi/\n1.4 pytorch环境安装 pytorch环境安装：https://pytorch.org/（注意选择合适版本）\n1.5安装ultralytics（yolov8）： (1) 安装zip总文件：\n🔹https://github.com/ultralytics/ultralytics\n(2) 终端进入文件夹\\ultralytics-main输入命令：pip install -e . 【后面的点要带！】\n【详细介绍还是不够的话可以参考此b站视频🤗🤗】 (3) ultralytics官方文档:\n🔹https://docs.ultralytics.com/zh/ 2. 模型预测及训练使用 2.1 标注图片环境下载 (1) 下载labelimg：pip install labelimg (2) 启动labelimg：labelimg 2.2 训练模型 (1) 标注完文件将文件创建好： Train-项目名 images train:（存放所有照片） val:（存放验证集照片） labels train:（存放所有标注后的.txt） val:（存放验证标志.txt） classes.txt（标注种类文件） (2) 创建好放到Train-项目名文件将文件放到datasets文件夹内 (3) 写好相应的yaml文件之后开始到tarin.py文件填好相应的文件路径和名称，最后开始训练 配置.yaml文件示例 1 2 3 4 5 6 7 8 9 10 path: Train-项目名 train: images/train val: images/val test: #可选项 names: 0: 标注时第一个标注对象名称 1: 标注时第二个标注对象名称 nc: 对象种类个数 train.py文件示例 1 2 3 4 5 6 7 from ultralytics import YOLO model = YOLO(\u0026#39;yolov8n.pt\u0026#39;) #参考预测模型文件，如果是自己的可以放自己last.pt文件继续训练 model.train(data=\u0026#39;配置.yaml\u0026#39;,workers=0,epochs=50,batch=16)#后面参数可自行根据训练硬件配置选择 print(\u0026#34;训练完成！\u0026#34;) (4) 训练完最终模型文件存放在runs/detect/trainxx/weights/xxx.pt 2.3 跑训练模型效果 简单使用示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from ultralytics import YOLO yolo = YOLO(\u0026#34;./best.pt\u0026#34;) # 小目标检测专用配置 result =yolo( source=\u0026#34;./detect_Text/Player.mp4\u0026#34;, show=True, conf=0.05, # 低置信度 imgsz=1280, # 大尺寸输入 iou=0.4, # 较低的IoU阈值 max_det=100, # 增加最大检测数量 agnostic_nms=False, # 类相关的NMS augment=True, # 测试时增强 ) # for i in result: # print(i.boxes.xywh.cpu().numpy()) 3. 最终训练效果展示 下面是我训练YOLOv8模型后的检测效果照片：(用的是我朋友之前在人民公园跟大爷一起踢毽子的视频，此处肖像权省略略略略😝😝😝，视频太大传不上去，又不想上传到地方托管，所以只取了其中一张照片)\n视频：YOLOv8模型在自定义数据集上的检测效果,数据集我训练的比较少,最终的视频效果一般,后面需要的话还是增大数据训练集\n4. 学习心得总结 🔅初步整个学习历程下来还是在配置训练环境，主要是学习到windos系统下的虚拟环境的配置，还有yolov8主要训练流程还有打标工具labelimg下载等等。详细的系统深度学习还有其他的标注工具可以参考小土堆up。后面还有更深度的具体如何实现深度学习的方法，卷积等等算法实现可以为后续深入地学习了解。还有后面如何将YOLO视觉具体应用到类似ROS上，如何视觉和底盘或者机械臂等协同工作的流程还要继续学习研究！本篇只作为初步入门学习使用YOLO😊.\n","date":"2025-09-01T00:00:00Z","image":"https://prominsegsj.github.io/p/yolo/1_hu_9bad58c53e2ff1d6.png","permalink":"https://prominsegsj.github.io/p/yolo/","title":"【机器视觉】yolo视觉检测"},{"content":"搭建·历程 时间线： 2025年：\n🔜 08/25 (开始搭建，初步发布和部署Github)\n🔜 08/26 (开始优化框架界面，头像、网站图标、文字字体等)\n🔜 08/27 (逐步增加背景粒子效果和底部动画效果，文章Tile居中等等)\n🔜 08/28 (更新优化Html界面，搜索及链接栏的布局排版，网站界面元素动画等)\n1. 问题 1.初步发布和部署Github\n2.主要的网站显示问题和优化界面\n3.如何新建和发布编写自己的文章\n2. 解决过程 2.1 核心搭建学习 主要学习b站up主（此处贴的他个人网站的那篇博客）：参考B站UP主的个人博客网站\n2.2 网站Logo显示问题 网站的favicon没有显示问题参考：favicon显示参考网址\n2.3 动态背景效果 在添加动态背景时粒子效果一直加载不成功，用b站up主的源码复制发现不行，后面换路径就可以了。\n2.4 Markdown博客编写 添加图片： 添加视频：(添加视频的大小容易超过100MB，上传Github容易失败，尽量将需要上创的视频托管到类似B站等视频平台) 1 2 3 4 \u0026lt;video width=\u0026#34;100%\u0026#34; controls poster=\u0026#34;封面照片.jpg\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;视频名称.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34;\u0026gt; 您的浏览器不支持Video标签，请尝试使用现代浏览器查看。 \u0026lt;/video\u0026gt; 文章写法： 文字内容示例： 加粗 斜体 删除线 代码写法示例： 在Markdown里用三个反引号开启/关闭代码块。指定语言后,Hugo 会自动高亮。 例1：python 1 2 def hello(): print(\u0026#34;Hello Hugo!\u0026#34;) 例2：c++ 1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, Hugo!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 换行示例： (1).两个空格＋回车 1 2 这是第一行（结尾有两个空格） 这是第二行 (2).空一行 1 2 3 这是第一段 这是第二段（中间有空行） (3).HTML换行标签 1 2 3 这是第一行\u0026lt;br\u0026gt; 这是第二行\u0026lt;br\u0026gt; 这是第三行 GitHub风格的块引用Alerts： 参考引用Alerts学习文章\n2.3 link栏修改 2.3.1 删除上方多余文章 将技术链接上面的文章栏去掉：在link.md文章增加，然后再新增的links.html文件中添好相关代码\n2.3.2 修改显示列表 技术链接改行数：my_web\\assets\\scss\\custom.scss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; /* 目前是两列，如需三列，则后面再加一个1fr，以此类推 */ grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 2.4 博客Tile居中 更改主页的文章标题及内容居中文件路径:assets\\scss\\custom.scss\n2.5 优化网站显示 2.5.1 网站运行时间 增加网站运行时间：layouts\\partials\\footer.html\n2.5.2 网页元素动画 给网页元素添加动画：assets\\scss\\custom.scss\n2.5.3 目录显示优化 将目录的自动排序取消：hugo.yaml文件内修改ordered参数\n2.6 新增项目栏 新增一个项目栏：先在content\\page项目栏里新增一个栏目名称，然后添加md文件。\n编写好md后为它在layouts\\page\\增加好对应名称的html布局文件就可以了。\n不需要更改其他关联，hugo会自动识别并且连接使用，主要确保layout属性挂到html文件就可以\n2.7 修改文字显示 修改主页栏名称：content_index.zh-cn.md\n2.8 新建博客文章 新创建一篇博客文章：终端命令执行：hugo new post\\新文章名称\\index.md生成后编写即可\n总结心得 心得我写在了8/28，这几天都在做这个网站，初步能看了才开始编写这篇内容，本人专业是软件但是学校课程学的非常少，基本都是期末一周极限“预习”，低分飘过及格线。(在这里我要非常非常感谢一下我的英语老师，大英一到四，捞了我整整四个学期，真的不夸张，3个学期60分！)机缘巧合我走了嵌入式，加了学校的机器人工作室，也算是2年入门(后面我想单独会写一篇博客来纪念一下我逝去的这两年)，但是本人其中在工作室或者说这个比赛的经历非常坎坷，后面会在那篇文章详细聊聊。说实话这个网站搭的我非常艰辛，基本上不是在修BUG，找资料，就是在问AI怎么做，因为我对前端可以说是一点知识没有，虽然好像上个学期刚学过JAVA，但是前面我给自己叠了甲！但是还是坚持搭了下去，因为或许我可以在这里写一些我想说的话，想记录一下我的生活和内容。希这个网站我会一直坚持和维护的。还想起来我到时候也要记一篇我喜欢听的音乐成长历程博客，在这里先给自己标记一下！😇😇以后我估计我会常常更新我的日常，还有想起来我学了这么多东西总要有个记录备份呐，所以这个网站就必然的营运而生咯！\u0026ldquo;悦己，越己！\u0026rdquo;\n","date":"2025-08-27T00:00:00Z","image":"https://prominsegsj.github.io/p/my-first-blog/5_hu_ba930173166397ba.jpg","permalink":"https://prominsegsj.github.io/p/my-first-blog/","title":"第一篇博客"},{"content":"","date":"2024-01-01T00:00:00Z","permalink":"https://prominsegsj.github.io/p/match_life/","title":"【致】大一到大二的参赛历练💤"},{"content":"","date":"2024-01-01T00:00:00Z","permalink":"https://prominsegsj.github.io/p/my_song_life/","title":"【致】我的音乐历史🫡"}]